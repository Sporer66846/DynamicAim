getgenv().SecureMode = true

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local Starlight = loadstring(game:HttpGet("https://raw.nebulasoftworks.xyz/starlight"))()  
local NebulaIcons = loadstring(game:HttpGet("https://raw.nebulasoftworks.xyz/nebula-icon-library-loader"))()

local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()
local espFolder = Instance.new("Folder")
espFolder.Parent = (gethui and gethui()) or game:GetService("CoreGui")

-- Logic Variables
local ESPDrawings = {}
local Target = nil
local CalibrationTarget = nil
local Aimbotting = nil
local rainbowing = nil
local Noclipping = nil
local ClippingParts = {}
local CalibrationLock = false

-- Prediction Dot Setup (2D Drawing for reliability)
local PredDotDrawing = Drawing.new("Circle")
PredDotDrawing.Color = Color3.new(1, 0, 0)
PredDotDrawing.Filled = true
PredDotDrawing.Thickness = 1
PredDotDrawing.Radius = 4
PredDotDrawing.Visible = false

-- Connection Storage for Unloading
local fovHeartbeat, combatHeartbeat, noRecoilRender, mainRenderLoop
local inputBeganConn, inputEndedConn, playerAddedConn, playerRemovingConn

-- State Tables
local Main = {
    WalkSpeedEnabled = false, WalkSpeed = 16,
    JumpPowerEnabled = false, JumpPower = 50,
    NoClipEnabled = false, GravityEnabled = false, Gravity = 196.2
}

local AimbotTargetPart = {
    Head = "Head", HumanoidRootPart = "HumanoidRootPart", Torso = "Torso",
    ["Right Arm"] = "Right Arm", ["Left Arm"] = "Left Arm",
    ["Right Leg"] = "Right Leg", ["Left Leg"] = "Left Leg", Legit = "Legit"
}

local AimbotFiltering = {
    ClosestToMouse = "ClosestToMouse",
    ClosestToPlayer = "ClosestToPlayer",
    LowestHealth = "LowestHealth"
}

local Aimbot = {
    Enabled = false, TeamCheck = false, VisibleCheck = false,
    TargetPart = AimbotTargetPart.Head, FOVCircle = false, FOV = 150,
    Range = 1000, Smoothness = 0.5, Filtering = AimbotFiltering.ClosestToMouse,
    Prediction = false, BulletSpeed = 1500, BulletDrop = false, BulletDropAmount = 50,
    Keybind = "MouseButton2", Visualizer = false
}

local Combat = {
    Triggerbot = false, TriggerDelay = 0.05, NoRecoil = false
}

local Visuals = {
    ESP = false, ESPColor = Color3.fromRGB(255, 255, 255), ESPHighlights = true,
    Tracers = false, TracerColor = Color3.fromRGB(255, 255, 255),
    Rainbow = false, InverseFriends = false, UseTeamColor = false,
    CurrentColor = Color3.new(1, 1, 1)
}

-- Window Setup
local Window = Starlight:CreateWindow({
    Name = "Dynamic Aim",
    Subtitle = "Precision Combat Suite",
    Icon = 110782178856576,
    LoadingSettings = { Title = "Dynamic Aim", Subtitle = "by Sporer66846" },
    ConfigurationSettings = { FolderName = "DynamicAimConfigs" }
})

local MainSection = Window:CreateTabSection("Main")
local MiscallaneousSection = Window:CreateTabSection("Miscellaneous")

local HomeTab = MainSection:CreateTab({ Name = "Home", Icon = NebulaIcons:GetIcon('home', 'Lucide'), Columns = 2 }, "Home_Tab")
local AimbotTab = MainSection:CreateTab({ Name = "Aimbot", Icon = NebulaIcons:GetIcon('mouse', 'Lucide'), Columns = 2 }, "Aimbot_Tab")
local CombatTab = MainSection:CreateTab({ Name = "Combat", Icon = NebulaIcons:GetIcon('swords', 'Lucide'), Columns = 2 }, "Combat_Tab")
local VisualsTab = MainSection:CreateTab({ Name = "Visuals", Icon = NebulaIcons:GetIcon('eye', 'Lucide'), Columns = 1 }, "Visuals_Tab")
local SettingsTab = MiscallaneousSection:CreateTab({ Name = "Settings", Icon = NebulaIcons:GetIcon('settings', 'Lucide'), Columns = 2 }, "Settings_Tab")
local CreditsTab = MiscallaneousSection:CreateTab({ Name = "Credits", Icon = NebulaIcons:GetIcon('info', 'Lucide'), Columns = 3 }, "Credits_Tab")

local CharacterGroupbox = HomeTab:CreateGroupbox({ Name = "Character", Column = 1 }, "Character_Groupbox")
local EnvironmentGroupbox = HomeTab:CreateGroupbox({ Name = "Environment", Column = 2 }, "Environment_Groupbox")
local AimbotSettingsGroupbox = AimbotTab:CreateGroupbox({ Name = "Aimbot Settings", Column = 1 }, "Aimbot_Settings_Groupbox")
local PredictionSettingsGroupbox = AimbotTab:CreateGroupbox({ Name = "Prediction Settings", Column = 2 }, "Prediction_Settings_Groupbox")
local CombatGroup = CombatTab:CreateGroupbox({ Name = "Calibration Tools", Column = 1 }, "Calibration_Groupbox")
local WeaponGroup = CombatTab:CreateGroupbox({ Name = "Weapon Mods", Column = 2 }, "WeaponMods_Groupbox")
local ESPSettingsGroupbox = VisualsTab:CreateGroupbox({ Name = "ESP Settings", Column = 1 }, "ESP_Settings_Groupbox")
local CreditsGroupbox = CreditsTab:CreateGroupbox({ Name = "Credits", Column = 1 }, "Credits_Groupbox")
local DonateGroupbox = CreditsTab:CreateGroupbox({ Name = "Donate", Column = 2 }, "Donate_Groupbox")
local SocialsGroupbox = CreditsTab:CreateGroupbox({ Name = "Socials", Column = 3 }, "Socials_Groupbox")

-- Character Settings
CharacterGroupbox:CreateToggle({
    Name = "WalkSpeed Enabled", CurrentValue = false, Style = 2,
    Callback = function(Value)
        Main.WalkSpeedEnabled = Value
        if Value then
            if Player.Character and Player.Character:FindFirstChild("Humanoid") then Player.Character.Humanoid.WalkSpeed = Main.WalkSpeed end
        else
            if Player.Character and Player.Character:FindFirstChild("Humanoid") then Player.Character.Humanoid.WalkSpeed = 16 end
        end
    end
}, "WalkSpeed_Toggle")

CharacterGroupbox:CreateSlider({
    Name = "WalkSpeed", Icon = NebulaIcons:GetIcon('chevrons-up', 'Lucide'), Range = {0, 500}, Increment = 1, CurrentValue = Main.WalkSpeed or 16,
    Callback = function(Value)
        Main.WalkSpeed = Value
        if Main.WalkSpeedEnabled and Player.Character and Player.Character:FindFirstChild("Humanoid") then
            Player.Character.Humanoid.WalkSpeed = Value
        end
    end
}, "WalkSpeed_Slider")

CharacterGroupbox:CreateToggle({
    Name = "JumpPower Enabled", CurrentValue = false, Style = 2,
    Callback = function(Value)
        Main.JumpPowerEnabled = Value
        if Value then
            if Player.Character and Player.Character:FindFirstChild("Humanoid") then Player.Character.Humanoid.JumpPower = Main.JumpPower end
        else
            if Player.Character and Player.Character:FindFirstChild("Humanoid") then Player.Character.Humanoid.JumpPower = 50 end
        end
    end
}, "JumpPower_Toggle")

CharacterGroupbox:CreateSlider({
    Name = "JumpPower", Icon = NebulaIcons:GetIcon('arrow-big-up-dash', 'Lucide'), Range = {0, 500}, Increment = 1, CurrentValue = Main.JumpPower or 50,
    Callback = function(Value)
        Main.JumpPower = Value
        if Main.JumpPowerEnabled and Player.Character and Player.Character:FindFirstChild("Humanoid") then
            Player.Character.Humanoid.JumpPower = Value
        end
    end
}, "JumpPower_Slider")

CharacterGroupbox:CreateToggle({
    Name = "NoClip Enabled", CurrentValue = false, Style = 2,
    Callback = function(Value)
        Main.NoClipEnabled = Value
        if Value then
            ClippingParts = {}
            local function NoclipLoop()
                if Main.NoClipEnabled == true and Player.Character ~= nil then
                    for _, child in pairs(Player.Character:GetDescendants()) do
                        if child:IsA("BasePart") and child.CanCollide == true then
                            child.CanCollide = false
                            if not table.find(ClippingParts, child) then table.insert(ClippingParts, child) end
                        end
                    end
                end
            end
            Noclipping = RunService.Stepped:Connect(NoclipLoop)
        else
            if Noclipping ~= nil then Noclipping:Disconnect() Noclipping = nil end
            for _, part in pairs(ClippingParts) do if part and part.Parent then part.CanCollide = true end end
            ClippingParts = {}
        end
    end
}, "NoClip_Toggle")

EnvironmentGroupbox:CreateToggle({
    Name = "Gravity Enabled", CurrentValue = false, Style = 2,
    Callback = function(Value)
        Main.GravityEnabled = Value
        workspace.Gravity = Value and Main.Gravity or 196.2
    end
}, "Gravity_Toggle")

EnvironmentGroupbox:CreateSlider({
    Name = "Gravity", Icon = NebulaIcons:GetIcon('earth', 'Lucide'), Range = {0, 500}, Increment = 0.1, CurrentValue = Main.Gravity or 196.2,
    Callback = function(Value)
        Main.Gravity = Value
        if Main.GravityEnabled then workspace.Gravity = Value end
    end
}, "Gravity_Slider")

-- Aimbot Settings
AimbotSettingsGroupbox:CreateToggle({
    Name = "Enabled", CurrentValue = false, Style = 2,
    Callback = function(Value) Aimbot.Enabled = Value end
}, "Aimbot_Toggle")

AimbotSettingsGroupbox:CreateToggle({
    Name = "Team Check", CurrentValue = false, Style = 2,
    Callback = function(v) Aimbot.TeamCheck = v end
}, "Aimbot_TeamCheck_Toggle")

AimbotSettingsGroupbox:CreateToggle({
    Name = "Visible Check", CurrentValue = false, Style = 2,
    Callback = function(v) Aimbot.VisibleCheck = v end
}, "Aimbot_VisibleCheck_Toggle")

local TargetPartLabel = AimbotSettingsGroupbox:CreateLabel({ Name = "Target Part" }, "TargetPart_Label")
TargetPartLabel:AddDropdown({
    Options = {"Head", "HumanoidRootPart", "Torso", "Right Arm", "Left Arm", "Right Leg", "Left Leg", "Legit"},
    CurrentOption = {"Head"}, MultipleOptions = false,
    Callback = function(Options) Aimbot.TargetPart = AimbotTargetPart[Options[1]] end,
}, "TargetPart_Dropdown")

local FilterLabel = AimbotSettingsGroupbox:CreateLabel({ Name = "Filtering" }, "Filtering_Label")
FilterLabel:AddDropdown({
    Options = {"ClosestToMouse", "ClosestToPlayer", "LowestHealth"},
    CurrentOption = {"ClosestToMouse"}, MultipleOptions = false,
    Callback = function(Options) Aimbot.Filtering = AimbotFiltering[Options[1]] end,
}, "Filtering_Dropdown")

local KeybindLabel = AimbotSettingsGroupbox:CreateLabel({ Name = "Aimbot Keybind" }, "Aimbot_Keybind_Label")
KeybindLabel:AddDropdown({
    Options = {"MouseButton2", "MouseButton1", "Q", "E", "F", "C", "V", "LeftAlt"},
    CurrentOption = {"MouseButton2"}, MultipleOptions = false,
    Callback = function(Options) Aimbot.Keybind = Options[1] end,
}, "Aimbot_Keybind_Dropdown")

local FOVCircle = Drawing.new("Circle")
FOVCircle.Color = Color3.new(1, 1, 1)
FOVCircle.Visible = false
FOVCircle.Filled = false
FOVCircle.Thickness = 1
FOVCircle.NumSides = 90

AimbotSettingsGroupbox:CreateToggle({
    Name = "FOV Circle", CurrentValue = false, Style = 2,
    Callback = function(Value)
        Aimbot.FOVCircle = Value
        if Value then
            FOVCircle.Visible = true
            fovHeartbeat = RunService.Heartbeat:Connect(function()
                local mouseLoc = UserInputService:GetMouseLocation()
                FOVCircle.Position = Vector2.new(mouseLoc.X, mouseLoc.Y)
            end)
        else
            FOVCircle.Visible = false
            if fovHeartbeat then fovHeartbeat:Disconnect() fovHeartbeat = nil end
        end
    end
}, "FOVCircle_Toggle")

AimbotSettingsGroupbox:CreateSlider({
    Name = "FOV Radius", Icon = NebulaIcons:GetIcon('radius', 'Lucide'), Range = {0, 1000}, Increment = 1, CurrentValue = Aimbot.FOV or 150,
    Callback = function(Value)
        Aimbot.FOV = Value
        if Aimbot.FOVCircle then FOVCircle.Radius = Value end
    end
}, "FOV_Slider")

AimbotSettingsGroupbox:CreateSlider({
    Name = "Target Range", Icon = NebulaIcons:GetIcon('binoculars', 'Lucide'), Range = {0, 10000}, Increment = 1, CurrentValue = Aimbot.Range or 1000,
    Callback = function(Value) Aimbot.Range = Value end
}, "Range_Slider")

AimbotSettingsGroupbox:CreateSlider({
    Name = "Smoothness", Icon = NebulaIcons:GetIcon('chart-spline', 'Lucide'), Range = {0.1, 1}, Increment = 0.05, CurrentValue = Aimbot.Smoothness or 0.5,
    Callback = function(Value) Aimbot.Smoothness = Value end
}, "Smoothness_Slider")

PredictionSettingsGroupbox:CreateToggle({
    Name = "Prediction", CurrentValue = false, Style = 2,
    Callback = function(Value) Aimbot.Prediction = Value end
}, "Prediction_Toggle")

PredictionSettingsGroupbox:CreateToggle({
    Name = "Show Prediction Dot", CurrentValue = false, Style = 2,
    Callback = function(v) 
        Aimbot.Visualizer = v 
        if not v then PredDotDrawing.Visible = false end
    end
}, "Visualizer_Toggle")

local BulletSpeedSlider = PredictionSettingsGroupbox:CreateSlider({
    Name = "Bullet Speed", Icon = NebulaIcons:GetIcon('gauge', 'Lucide'), Range = {10, 10000}, Increment = 10, CurrentValue = Aimbot.BulletSpeed or 1500,
    Callback = function(Value) Aimbot.BulletSpeed = Value end
}, "BulletSpeed_Slider")

PredictionSettingsGroupbox:CreateToggle({
    Name = "Bullet Drop", CurrentValue = false, Style = 2,
    Callback = function(Value) Aimbot.BulletDrop = Value end
}, "BulletDrop_Toggle")

local BulletDropSlider = PredictionSettingsGroupbox:CreateSlider({
    Name = "Drop Amount", Icon = NebulaIcons:GetIcon('arrow-down-to-line', 'Lucide'), Range = {1, 200}, Increment = 1, CurrentValue = Aimbot.BulletDropAmount or 50,
    Callback = function(Value) Aimbot.BulletDropAmount = Value end
}, "BulletDrop_Slider")


-- Combat Tab
WeaponGroup:CreateToggle({ Name = "Triggerbot", CurrentValue = false, Style = 2, Callback = function(v) Combat.Triggerbot = v end }, "Triggerbot_Toggle")
WeaponGroup:CreateSlider({ Name = "Trigger Delay", Range = {0, 1}, Increment = 0.01, CurrentValue = 0.05, Callback = function(v) Combat.TriggerDelay = v end }, "TriggerDelay_Slider")
WeaponGroup:CreateToggle({ Name = "No Recoil", CurrentValue = false, Style = 2, Callback = function(v) Combat.NoRecoil = v end }, "NoRecoil_Toggle")

local PlayerList = {"None"}
for _, p in pairs(Players:GetPlayers()) do if p ~= Player then table.insert(PlayerList, p.Name) end end

local TargetDropdownLabel = CombatGroup:CreateLabel({ Name = "Calibration Target" }, "CalibrationTarget_Label")
local TargetDropdown = TargetDropdownLabel:AddDropdown({
    Options = PlayerList, CurrentOption = {"None"}, MultipleOptions = false,
    Callback = function(val) CalibrationTarget = Players:FindFirstChild(val[1] or val) end
}, "CalibrationTarget_Dropdown")

playerAddedConn = Players.PlayerAdded:Connect(function(p)
    if p ~= Player then table.insert(PlayerList, p.Name); pcall(function() TargetDropdown:SetOptions(PlayerList) end) end
end)

playerRemovingConn = Players.PlayerRemoving:Connect(function(p)
    for i, name in ipairs(PlayerList) do 
        if name == p.Name then table.remove(PlayerList, i); pcall(function() TargetDropdown:SetOptions(PlayerList) end); break end 
    end
end)

-- Calibration Target Helper
local function GetCalibrationTargetModel()
    if CalibrationTarget and CalibrationTarget ~= Player then
        local char = CalibrationTarget.Character
        if char and char:FindFirstChild("Humanoid") and char.Humanoid.Health > 0 then
            if not (Aimbot.TeamCheck and Player.Team and CalibrationTarget.Team and Player.Team == CalibrationTarget.Team) then
                return char
            end
        end
    end

    local nearestChar = nil
    local minDist = math.huge
    local mouseLoc = UserInputService:GetMouseLocation()

    for _, hum in ipairs(workspace:GetDescendants()) do
        if hum:IsA("Humanoid") and hum.Health > 0 then
            local char = hum.Parent
            if char and char:IsA("Model") and char ~= Player.Character then
                local root = char:FindFirstChild("HumanoidRootPart")
                if root then
                    local targetPlayer = Players:GetPlayerFromCharacter(char)
                    if targetPlayer and Aimbot.TeamCheck and Player.Team and targetPlayer.Team and targetPlayer.Team == Player.Team then
                        continue
                    end

                    local screenPoint, onScreen = workspace.CurrentCamera:WorldToScreenPoint(root.Position)
                    if onScreen and screenPoint.Z > 0 then
                        local dx = screenPoint.X - mouseLoc.X
                        local dy = screenPoint.Y - mouseLoc.Y
                        local dist = math.sqrt(dx*dx + dy*dy)
                        if dist < minDist then
                            minDist = dist
                            nearestChar = char
                        end
                    end
                end
            end
        end
    end
    return nearestChar
end

-- SPEED CALIBRATION (Manual Fire & Anti UI-Click Debounce)
CombatGroup:CreateButton({ Name = "Calibrate Speed", Icon = NebulaIcons:GetIcon('target', 'Lucide'), Style = 1, Callback = function()
    if CalibrationLock then return end
    
    local targetChar = GetCalibrationTargetModel()
    if not targetChar then
        Starlight:Notification({ Title = "Error", Content = "No valid enemy targets found.", Duration = 3 })
        return
    end

    CalibrationLock = true
    local targetPartName = Aimbot.TargetPart == "Legit" and "Head" or Aimbot.TargetPart
    local targetPart = targetChar:FindFirstChild(targetPartName) or targetChar:FindFirstChild("HumanoidRootPart")
    
    Starlight:Notification({ Title = "Calibration", Content = "Locked on! Equip a gun and fire manually (5s timeout).", Duration = 5 })

    -- Lock Camera
    local aimConn = RunService.RenderStepped:Connect(function()
        if targetPart then
            workspace.CurrentCamera.CFrame = CFrame.lookAt(workspace.CurrentCamera.CFrame.Position, targetPart.Position)
        end
    end)

    task.spawn(function()
        task.wait(0.5) -- Give the user half a second to let go of the UI click

        local shotFired = false
        local inputConn = UserInputService.InputBegan:Connect(function(input, gp)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                shotFired = true
            end
        end)

        local waitTime = 0
        while not shotFired and waitTime < 5 do
            task.wait(0.1)
            waitTime = waitTime + 0.1
        end
        
        inputConn:Disconnect()

        if not shotFired then
            Starlight:Notification({ Title = "Error", Content = "Calibration timed out. You didn't shoot.", Duration = 3 })
            if aimConn then aimConn:Disconnect() end
            CalibrationLock = false
            return
        end

        local initialHealth = targetChar.Humanoid.Health
        local distance = (targetPart.Position - workspace.CurrentCamera.CFrame.Position).Magnitude
        local startTime = os.clock()
        local success = false

        while os.clock() - startTime < 1 do
            if targetChar.Humanoid.Health < initialHealth - 0.1 then
                local t = os.clock() - startTime
                if t > 0 then
                    Aimbot.BulletSpeed = math.floor(distance / t)
                    BulletSpeedSlider:Set(Aimbot.BulletSpeed)
                    Starlight:Notification({ Title = "Success", Content = "Speed set to: " .. Aimbot.BulletSpeed, Duration = 3 })
                end
                success = true 
                break
            end
            task.wait()
        end
        
        if not success then 
            Starlight:Notification({ Title = "Error", Content = "No hit detected within 1 second.", Duration = 3 }) 
        end
        if aimConn then aimConn:Disconnect() end
        CalibrationLock = false
    end)
end}, "CalibrateSpeed_Button")

-- DROP CALIBRATION (Manual Fire & Anti UI-Click Debounce)
CombatGroup:CreateButton({ Name = "Calibrate Drop", Icon = NebulaIcons:GetIcon('arrow-down', 'Lucide'), Style = 1, Callback = function()
    if CalibrationLock then return end
    
    local targetChar = GetCalibrationTargetModel()
    if not targetChar then
        Starlight:Notification({ Title = "Error", Content = "No valid enemy targets found.", Duration = 3 })
        return
    end

    CalibrationLock = true
    local targetPartName = Aimbot.TargetPart == "Legit" and "Head" or Aimbot.TargetPart
    local targetPart = targetChar:FindFirstChild(targetPartName) or targetChar:FindFirstChild("HumanoidRootPart")
    
    Starlight:Notification({ Title = "Calibration", Content = "Locked on! Equip a gun and fire manually (5s timeout).", Duration = 5 })

    -- Lock Camera
    local aimConn = RunService.RenderStepped:Connect(function()
        if targetPart then
            workspace.CurrentCamera.CFrame = CFrame.lookAt(workspace.CurrentCamera.CFrame.Position, targetPart.Position)
        end
    end)

    task.spawn(function()
        task.wait(0.5) -- Give the user half a second to let go of the UI click

        local shotFired = false
        local inputConn = UserInputService.InputBegan:Connect(function(input, gp)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                shotFired = true
            end
        end)

        local waitTime = 0
        while not shotFired and waitTime < 5 do
            task.wait(0.1)
            waitTime = waitTime + 0.1
        end
        
        inputConn:Disconnect()

        if not shotFired then
            Starlight:Notification({ Title = "Error", Content = "Calibration timed out. You didn't shoot.", Duration = 3 })
            if aimConn then aimConn:Disconnect() end
            CalibrationLock = false
            return
        end

        local initialHealth = targetChar.Humanoid.Health
        local startTime = os.clock()
        local success = false

        while os.clock() - startTime < 1 do
            if targetChar.Humanoid.Health < initialHealth - 0.1 then
                local t = os.clock() - startTime
                if t > 0 then
                    local estimatedDrop = math.floor(196.2 * (t * 2))
                    Aimbot.BulletDropAmount = math.clamp(estimatedDrop, 0, 500)
                    BulletDropSlider:Set(Aimbot.BulletDropAmount)
                    Starlight:Notification({ Title = "Success", Content = "Drop Factor Adjusted: " .. Aimbot.BulletDropAmount, Duration = 3 })
                end
                success = true
                break
            end
            task.wait()
        end
        
        if not success then 
            Starlight:Notification({ Title = "Error", Content = "No hit detected within 1 second.", Duration = 3 }) 
        end
        if aimConn then aimConn:Disconnect() end
        CalibrationLock = false
    end)
end}, "CalibrateDrop_Button")


-- Visuals Tab
ESPSettingsGroupbox:CreateToggle({
    Name = "Enabled", CurrentValue = false, Style = 2,
    Callback = function(Value)
        Visuals.ESP = Value
        if not Value then espFolder:ClearAllChildren() end
    end
}, "ESP_Toggle")

ESPSettingsGroupbox:CreateToggle({
    Name = "Tracers", CurrentValue = false, Style = 2,
    Callback = function(Value) Visuals.Tracers = Value end
}, "Tracers_Toggle")

ESPSettingsGroupbox:CreateToggle({
    Name = "Use Team Color", CurrentValue = false, Style = 2,
    Callback = function(Value) Visuals.UseTeamColor = Value end
}, "UseTeamColor_Toggle")

ESPSettingsGroupbox:CreateToggle({
    Name = "Inverse Friends", CurrentValue = false, Style = 2,
    Callback = function(Value) Visuals.InverseFriends = Value end
}, "InverseFriends_Toggle")

ESPSettingsGroupbox:CreateToggle({
    Name = "Rainbow", CurrentValue = false, Style = 2,
    Callback = function(Value)
        Visuals.Rainbow = Value
        if Value then
            rainbowing = RunService.RenderStepped:Connect(function()
                Visuals.CurrentColor = Color3.fromHSV((os.clock() * 0.2) % 1, 1, 1)
            end)
        else
            Visuals.CurrentColor = Color3.new(1, 1, 1)
            if rainbowing then rainbowing:Disconnect() rainbowing = nil end
        end
    end
}, "Rainbow_Toggle")


-- Settings & Configs Tab
SettingsTab:BuildConfigGroupbox(1)
SettingsTab:BuildThemeGroupbox(2)

local SettingsUtilityGroupbox = SettingsTab:CreateGroupbox({ Name = "Utility", Column = 1 }, "Utility_Groupbox")

local function UnloadScript()
    if Player.Character and Player.Character:FindFirstChild("Humanoid") then
        Player.Character.Humanoid.WalkSpeed = 16
        Player.Character.Humanoid.JumpPower = 50
    end
    workspace.Gravity = 196.2

    if Noclipping then Noclipping:Disconnect() Noclipping = nil end
    for _, part in pairs(ClippingParts) do
        if part and part.Parent then part.CanCollide = true end
    end
    ClippingParts = {}

    if espFolder then espFolder:Destroy() end

    if FOVCircle then
        FOVCircle.Visible = false
        FOVCircle:Remove()
    end
    
    if PredDotDrawing then
        PredDotDrawing.Visible = false
        PredDotDrawing:Remove()
    end

    for _, obj in pairs(ESPDrawings) do
        if obj.Tracer then obj.Tracer.Visible = false obj.Tracer:Remove() end
        if obj.NameText then obj.NameText.Visible = false obj.NameText:Remove() end
    end

    if Aimbotting then Aimbotting:Disconnect() end
    if rainbowing then rainbowing:Disconnect() end
    if fovHeartbeat then fovHeartbeat:Disconnect() end
    if combatHeartbeat then combatHeartbeat:Disconnect() end
    if noRecoilRender then noRecoilRender:Disconnect() end
    if mainRenderLoop then mainRenderLoop:Disconnect() end
    if inputBeganConn then inputBeganConn:Disconnect() end
    if inputEndedConn then inputEndedConn:Disconnect() end
    if playerAddedConn then playerAddedConn:Disconnect() end
    if playerRemovingConn then playerRemovingConn:Disconnect() end

    pcall(function() Window:Destroy() end)
    pcall(function() Starlight:Unload() end)
end

SettingsUtilityGroupbox:CreateButton({
    Name = "Unload Script",
    Icon = NebulaIcons:GetIcon('trash-2', 'Lucide'),
    Style = 2,
    Callback = UnloadScript
}, "Unload_Button")


-- Credits Tab
CreditsGroupbox:CreateLabel({
    Name = "Credits:", Content = "Script made by Sporer66846\nUI Library made by Nebula Softworks\nVersion 3.0",
}, "Credits_Label")

DonateGroupbox:CreateButton({
    Name = "Copy Bitcoin Wallet", Icon = NebulaIcons:GetIcon('bitcoin', 'Lucide'), Style = 1,
    Callback = function() setclipboard("bc1q54wdp3xrhmrpcqnlqf72rlmmjg7c83fj30n43u") end,
}, "CopyBitcoin_Button")

DonateGroupbox:CreateButton({
    Name = "Copy Etherium Wallet", Icon = NebulaIcons:GetIcon('gpu', 'Lucide'), Style = 1,
    Callback = function() setclipboard("0x75BbcC2aaEdef8d5205c0B6DFCa85c20C9aE608A") end,
}, "CopyEtherium_Button")

SocialsGroupbox:CreateButton({
    Name = "Copy Discord Link", Icon = NebulaIcons:GetIcon('bot', 'Lucide'), Style = 1,
    Callback = function() setclipboard("https://discord.gg/CSzZPNwUWY") end,
}, "CopyDiscord_Button")


-- Utility & Cache Functions
local friendCache = {}
local function isPlayerFriend(targetPlayer)
    if friendCache[targetPlayer.UserId] ~= nil then return friendCache[targetPlayer.UserId] end
    friendCache[targetPlayer.UserId] = false
    task.spawn(function()
        local success, result = pcall(function() return Player:IsFriendsWith(targetPlayer.UserId) end)
        if success then friendCache[targetPlayer.UserId] = result end
    end)
    return friendCache[targetPlayer.UserId]
end

local function getColorForPlayer(player)
    if Visuals.UseTeamColor and player.Team then return player.TeamColor.Color end
    local baseColor = Visuals.CurrentColor
    if Visuals.InverseFriends and isPlayerFriend(player) then
        local h, s, v = baseColor:ToHSV()
        return Color3.fromHSV((h + 0.5) % 1, s, v) 
    end
    return baseColor
end

local function worldToScreen(pos)
    local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(pos)
    return Vector2.new(screenPos.X, screenPos.Y), onScreen
end

local function IsVisible(part)
    if not Aimbot.VisibleCheck then return true end
    local char = Player.Character
    if not char then return false end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {char}
    local dir = (part.Position - workspace.CurrentCamera.CFrame.Position)
    local result = workspace:Raycast(workspace.CurrentCamera.CFrame.Position, dir, params)
    if result then
        if result.Instance:IsDescendantOf(part.Parent) then return true end
        return false
    end
    return true
end


-- Optimized Combat Background Loops
local triggerbotDebounce = false
combatHeartbeat = RunService.Heartbeat:Connect(function()
    if Combat.Triggerbot and not triggerbotDebounce then
        local mouseLoc = UserInputService:GetMouseLocation()
        local ray = workspace.CurrentCamera:ViewportPointToRay(mouseLoc.X, mouseLoc.Y)
        
        local params = RaycastParams.new()
        params.FilterType = Enum.RaycastFilterType.Exclude
        if Player.Character then params.FilterDescendantsInstances = {Player.Character} end

        local result = workspace:Raycast(ray.Origin, ray.Direction * 1000, params)
        
        if result and result.Instance then
            local model = result.Instance:FindFirstAncestorOfClass("Model")
            if model and model:FindFirstChild("Humanoid") and model.Humanoid.Health > 0 then
                local hitPlayer = Players:GetPlayerFromCharacter(model)
                if hitPlayer and hitPlayer ~= Player then
                    if Aimbot.TeamCheck and hitPlayer.Team and Player.Team and hitPlayer.Team == Player.Team then return end
                    
                    triggerbotDebounce = true
                    task.spawn(function()
                        task.wait(Combat.TriggerDelay)
                        mouse1press()
                        task.wait(0.05)
                        mouse1release()
                        task.wait(0.05) 
                        triggerbotDebounce = false
                    end)
                end
            end
        end
    end
end)

local LastCameraRotation = workspace.CurrentCamera.CFrame
noRecoilRender = RunService.RenderStepped:Connect(function()
    if Combat.NoRecoil then
        if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then 
            workspace.CurrentCamera.CFrame = LastCameraRotation 
        end
        LastCameraRotation = workspace.CurrentCamera.CFrame
    else 
        LastCameraRotation = workspace.CurrentCamera.CFrame 
    end
end)


-- Aimbot Target Calculation Distance Helpers
local function GetPlayerDistance(targetPlayer)
    local targetCharacter = targetPlayer.Character
    if not targetCharacter then return end
    local targetHumanoidRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    local Character = Player.Character
    if not Character then return end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")

    if not targetHumanoidRootPart or not HumanoidRootPart then return end
    return (targetHumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
end

local function GetMouseDistanceToPlayer(player)
    local char = player.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return math.huge end

    local screenPoint, onScreen = workspace.CurrentCamera:WorldToScreenPoint(root.Position)
    if screenPoint.Z <= 0 then return math.huge end

    local mouseLoc = UserInputService:GetMouseLocation()
    local dx = screenPoint.X - mouseLoc.X
    local dy = screenPoint.Y - mouseLoc.Y
    return math.sqrt(dx*dx + dy*dy)
end

-- Aimbot Target Acquisition
local function GetAimbotTarget()
    local playerList = Players:GetPlayers()
    local closestPlayer = nil
    
    if Aimbot.Filtering == "ClosestToMouse" then
        local shortestDistance = Aimbot.FOV
        for _, p in ipairs(playerList) do
            if ValidTargetCheck(p) then
                local dist2d = GetMouseDistanceToPlayer(p)
                if dist2d and dist2d < shortestDistance then
                    local pDist = GetPlayerDistance(p)
                    if pDist and pDist <= Aimbot.Range then
                        shortestDistance = dist2d
                        closestPlayer = p
                    end
                end
            end
        end
    elseif Aimbot.Filtering == "ClosestToPlayer" then
        local shortestDistance = Aimbot.Range
        for _, p in ipairs(playerList) do
            if ValidTargetCheck(p) then
                local dist = GetPlayerDistance(p)
                local checkFOV = (GetMouseDistanceToPlayer(p) < Aimbot.FOV)
                if dist and dist < shortestDistance and checkFOV then
                    closestPlayer = p
                    shortestDistance = dist
                end
            end
        end
    elseif Aimbot.Filtering == "LowestHealth" then
        local lowestHealth = math.huge
        for _, p in ipairs(playerList) do
            if ValidTargetCheck(p) then
                local humanoid = p.Character:FindFirstChild("Humanoid")
                local dist = GetPlayerDistance(p)
                local checkFOV = (GetMouseDistanceToPlayer(p) < Aimbot.FOV)
                if dist and dist <= Aimbot.Range and checkFOV and humanoid.Health < lowestHealth then
                    closestPlayer = p
                    lowestHealth = humanoid.Health
                end
            end
        end
    end
    
    return closestPlayer
end

-- Screen Drawing Prediction Visualizer
local function UpdatePredictionDot()
    if not Aimbot.Enabled or not Aimbot.Visualizer then 
        PredDotDrawing.Visible = false
        return 
    end

    local bestTarget = Target or GetAimbotTarget()
    
    if not bestTarget or not bestTarget.Character or not bestTarget.Character:FindFirstChild("HumanoidRootPart") then
        PredDotDrawing.Visible = false
        return
    end
    
    local rootPart = bestTarget.Character:FindFirstChild("HumanoidRootPart")
    local targetPartName = Aimbot.TargetPart == "Legit" and "Head" or Aimbot.TargetPart
    local part = bestTarget.Character:FindFirstChild(targetPartName) or rootPart
    
    local position = part.Position
    
    if Aimbot.Prediction and Aimbot.BulletSpeed > 0 then
        local distance = (position - workspace.CurrentCamera.CFrame.Position).Magnitude
        local bulletTravelTime = distance / Aimbot.BulletSpeed
        position = position + (rootPart.Velocity * bulletTravelTime)
        if Aimbot.BulletDrop and Aimbot.BulletDropAmount > 0 then
            local drop = 0.5 * Aimbot.BulletDropAmount * (bulletTravelTime^2)
            position = Vector3.new(position.X, position.Y + drop, position.Z)
        end
    end
    
    local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(position)
    if onScreen then
        PredDotDrawing.Position = Vector2.new(screenPos.X, screenPos.Y)
        PredDotDrawing.Visible = true
    else
        PredDotDrawing.Visible = false
    end
end


-- Main Render/ESP Loop
mainRenderLoop = RunService.RenderStepped:Connect(function()
    UpdatePredictionDot()

    local camera = workspace.CurrentCamera
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= Player then
            if not ESPDrawings[p] then
                ESPDrawings[p] = { Tracer = Drawing.new("Line"), NameText = Drawing.new("Text") }
            end

            local tracer = ESPDrawings[p].Tracer
            local nameText = ESPDrawings[p].NameText
            tracer.Visible = false
            nameText.Visible = false

            if p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = p.Character:FindFirstChild("HumanoidRootPart")
                local head = p.Character:FindFirstChild("Head")
                local humanoid = p.Character:FindFirstChild("Humanoid")
                
                if humanoid and humanoid.Health > 0 then
                    local colorToUse = (Target == p) and Color3.new(1, 0, 0) or getColorForPlayer(p)

                    if Visuals.ESP then
                        local espObj = espFolder:FindFirstChild(p.Name .. "_ESP")
                        if not espObj then
                            espObj = Instance.new("Highlight")
                            espObj.Name = p.Name .. "_ESP"
                            espObj.Parent = espFolder
                            espObj.FillTransparency = 1
                            espObj.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                        end
                        espObj.Adornee = p.Character
                        espObj.OutlineColor = colorToUse
                    else
                        local espObj = espFolder:FindFirstChild(p.Name .. "_ESP")
                        if espObj then espObj:Destroy() end
                    end

                    if Visuals.Tracers and hrp then
                        local screenPos, onScreen = worldToScreen(hrp.Position)
                        if onScreen then
                            tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y) 
                            tracer.To = screenPos
                            tracer.Color = colorToUse
                            tracer.Thickness = 1.5
                            tracer.Transparency = 1
                            tracer.Visible = true
                        end
                    end

                    if Visuals.ESP and head then
                        local namePos, onScreen = worldToScreen(head.Position + Vector3.new(0, 3, 0))
                        if onScreen then
                            local txt = p.Name
                            if isPlayerFriend(p) then txt = "(Friend) " .. txt end
                            nameText.Text = txt
                            nameText.Position = Vector2.new(namePos.X, namePos.Y - 30)
                            nameText.Size = 14
                            nameText.Color = colorToUse
                            nameText.Center = true
                            nameText.Outline = true
                            nameText.OutlineColor = Color3.new(0, 0, 0)
                            nameText.Visible = true
                        end
                    end
                end
            end
        end
    end
end)


local function aimbotKeyDown()
    if Aimbot.Enabled == false then return end
    if Aimbotting then Aimbotting:Disconnect() Aimbotting = nil end

    Target = GetAimbotTarget()
    if Target == nil then return end

    local switchInterval = 0.3
    local lastSwitchTime = 0
    local currentPart = nil
    local camera = workspace.CurrentCamera

    local function ManipulateCamera(deltaTime)
        if not Target or not Target.Character or not Target.Character:FindFirstChild("Humanoid") or Target.Character.Humanoid.Health <= 0 then
            if Aimbotting then Aimbotting:Disconnect() Aimbotting = nil end
            Target = nil
            return
        end

        local rootPart = Target.Character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end

        local position
        if Aimbot.TargetPart ~= "Legit" then
            local part = Target.Character:FindFirstChild(Aimbot.TargetPart)
            if not part then return end
            position = part.Position
            currentPart = nil
            lastSwitchTime = os.clock()
        else
            local now = os.clock()
            if not currentPart or now - lastSwitchTime >= switchInterval then
                lastSwitchTime = now
                local parts = {Target.Character:FindFirstChild("Head"), Target.Character:FindFirstChild("UpperTorso") or Target.Character:FindFirstChild("Torso"), rootPart}
                currentPart = parts[math.random(1, #parts)] or rootPart
            end
            position = currentPart.Position
        end

        if Aimbot.Prediction and Aimbot.BulletSpeed > 0 then
            local distance = (position - camera.CFrame.Position).Magnitude
            local bulletTravelTime = distance / Aimbot.BulletSpeed
            position = position + rootPart.Velocity * bulletTravelTime
            if Aimbot.BulletDrop and Aimbot.BulletDropAmount > 0 then
                local drop = 0.5 * Aimbot.BulletDropAmount * bulletTravelTime^2
                position = Vector3.new(position.X, position.Y + drop, position.Z)
            end
        end

        local newCFrame = CFrame.lookAt(camera.CFrame.Position, position)
        local alpha = 1 - math.pow(1 - Aimbot.Smoothness, deltaTime * 60)
        camera.CFrame = camera.CFrame:Lerp(newCFrame, math.clamp(alpha, 0, 1))
    end

    Aimbotting = RunService.RenderStepped:Connect(ManipulateCamera)
end

local function aimbotKeyUp()
    if Aimbotting ~= nil then
        Aimbotting:Disconnect()
        Aimbotting = nil
    end
    Target = nil
end

inputBeganConn = UserInputService.InputBegan:Connect(function(input, gameprocessed)
    if gameprocessed then return end
    local keyName = (input.UserInputType == Enum.UserInputType.Keyboard) and input.KeyCode.Name or input.UserInputType.Name
    if keyName == Aimbot.Keybind then aimbotKeyDown() end
end)

inputEndedConn = UserInputService.InputEnded:Connect(function(input, gameprocessed)
    local keyName = (input.UserInputType == Enum.UserInputType.Keyboard) and input.KeyCode.Name or input.UserInputType.Name
    if keyName == Aimbot.Keybind then aimbotKeyUp() end
end)

Starlight:LoadAutoloadConfig()

-- Disables Acrylic/Blur systems according to the Starlight documentation
getgenv().SecureMode = true

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local Starlight = loadstring(game:HttpGet("https://raw.nebulasoftworks.xyz/starlight"))()  
local NebulaIcons = loadstring(game:HttpGet("https://raw.nebulasoftworks.xyz/nebula-icon-library-loader"))()

local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()

local espFolder = Instance.new("Folder")
espFolder.Parent = (gethui and gethui()) or game:GetService("CoreGui")

-- Logic Variables
local ESPDrawings = {}
local VisualizerLines = {}
local Target = nil
local CalibrationTarget = nil
local Aimbotting = nil
local rainbowing = nil
local Noclipping = nil
local ClippingParts = {}
local CalibrationLock = false

-- Config
local Actions = {
    Aimbot = "ACTION_AIMBOT"
}

local Main = {
    WalkSpeedEnabled = true,
    WalkSpeed = 16,
    JumpPowerEnabled = true,
    JumpPower = 50,
    NoClipEnabled = false,
    GravityEnabled = true,
    Gravity = 196.2
}

local AimbotTargetPart = {
    Head = "Head",
    HumanoidRootPart = "HumanoidRootPart",
    Torso = "Torso",
    ["Right Arm"] = "Right Arm",
    ["Left Arm"] = "Left Arm",
    ["Right Leg"] = "Right Leg",
    ["Left Leg"] = "Left Leg",
    Legit = "Legit",
}

local AimbotFiltering = {
    ClosestToMouse = "ClosestToMouse",
    ClosestToPlayer = "ClosestToPlayer",
    LowestHealth = "LowestHealth",
}

local Aimbot = {
    Enabled = false,
    TeamCheck = false,
    VisibleCheck = true,
    TargetPart = AimbotTargetPart.Head,
    FOVCircle = true,
    FOV = 150,
    Range = 1000,
    Smoothness = 0.5,
    Filtering = AimbotFiltering.ClosestToMouse,
    Prediction = false,
    BulletSpeed = 1500,
    BulletDrop = false,
    BulletDropAmount = 50,
    Keybind = "MouseButton2",
    Visualizer = false
}

local Combat = {
    Triggerbot = false,
    TriggerDelay = 0.05,
    NoRecoil = false
}

local Visuals = {
    ESP = false,
    ESPColor = Color3.fromRGB(255, 255, 255),
    ESPHighlights = true,
    Tracers = true,
    TracerColor = Color3.fromRGB(255, 255, 255),
    Rainbow = false,
    InverseFriends = false,
    UseTeamColor = false,
    CurrentColor = Color3.new(1, 1, 1),
}

local Window = Starlight:CreateWindow({
    Name = "Dynamic Aim",
    Subtitle = "A dynamic aiming system for Roblox games",
    Icon = 110782178856576, 
    LoadingSettings = {
        Title = "Dynamic Aim",
        Subtitle = "by Sporer66846"
    },
    ConfigurationSettings = {
        FolderName = "DynamicAimConfigs"
    }
})

local MainSection = Window:CreateTabSection("Main")
local MiscallaneousSection = Window:CreateTabSection("Miscellaneous")

local HomeTab = MainSection:CreateTab({
    Name = "Home",
    Icon = NebulaIcons:GetIcon('home', 'Lucide'),
    Columns = 2
}, "Home_Tab")

local AimbotTab = MainSection:CreateTab({
    Name = "Aimbot",
    Icon = NebulaIcons:GetIcon('mouse', 'Lucide'),
    Columns = 2
}, "Aimbot_Tab")

local CombatTab = MainSection:CreateTab({ 
    Name = "Combat", 
    Icon = NebulaIcons:GetIcon('swords', 'Lucide'), 
    Columns = 2 
}, "Combat_Tab")

local VisualsTab = MainSection:CreateTab({
    Name = "Visuals",
    Icon = NebulaIcons:GetIcon('eye', 'Lucide'),
    Columns = 1
}, "Visuals_Tab")

local SettingsTab = MiscallaneousSection:CreateTab({
    Name = "Settings",
    Icon = NebulaIcons:GetIcon('settings', 'Lucide'),
    Columns = 2
}, "Settings_Tab")

local CreditsTab = MiscallaneousSection:CreateTab({
    Name = "Credits",
    Icon = NebulaIcons:GetIcon('info', 'Lucide'),
    Columns = 3
}, "Credits_Tab")

local CharacterGroupbox = HomeTab:CreateGroupbox({ Name = "Character", Column = 1 }, "Character_Groupbox")
local EnvironmentGroupbox = HomeTab:CreateGroupbox({ Name = "Environment", Column = 2 }, "Environment_Groupbox")
local AimbotSettingsGroupbox = AimbotTab:CreateGroupbox({ Name = "Aimbot Settings", Column = 1 }, "Aimbot_Settings_Groupbox")
local PredictionSettingsGroupbox = AimbotTab:CreateGroupbox({ Name = "Prediction Settings", Column = 2 }, "Prediction_Settings_Groupbox")
local CombatGroup = CombatTab:CreateGroupbox({ Name = "Calibration Tools", Column = 1 })
local WeaponGroup = CombatTab:CreateGroupbox({ Name = "Weapon Mods", Column = 2 })
local ESPSettingsGroupbox = VisualsTab:CreateGroupbox({ Name = "ESP Settings", Column = 1 }, "ESP_Settings_Groupbox")
local CreditsGroupbox = CreditsTab:CreateGroupbox({ Name = "Credits", Column = 1 }, "Credits_Groupbox")
local DonateGroupbox = CreditsTab:CreateGroupbox({ Name = "Donate", Column = 2 }, "Donate_Groupbox")
local SocialsGroupbox = CreditsTab:CreateGroupbox({ Name = "Socials", Column = 3 }, "Socials_Groupbox")

-- Character Settings
local WalkSpeedToggle = CharacterGroupbox:CreateToggle({
    Name = "WalkSpeed Enabled",
    CurrentValue = true, Style = 2,
    Callback = function(Value)
        Main.WalkSpeedEnabled = Value
        if Value then
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Main.WalkSpeed
        else
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16 
        end
    end
}, "WalkSpeed_Toggle")

local WalkSpeedSlider = CharacterGroupbox:CreateSlider({
    Name = "WalkSpeed", Icon = NebulaIcons:GetIcon('chevrons-up', 'Lucide'),
    Range = {0, 500}, Increment = 1, CurrentValue = Main.WalkSpeed or 16,
    Callback = function(Value)
        Main.WalkSpeed = Value
        if Main.WalkSpeedEnabled then
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
        end
    end
}, "WalkSpeed_Slider")

local JumpPowerToggle = CharacterGroupbox:CreateToggle({
    Name = "JumpPower Enabled", CurrentValue = true, Style = 2,
    Callback = function(Value)
        Main.JumpPowerEnabled = Value
        if Value then
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = Main.JumpPower
        else
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = 50 
        end
    end
}, "JumpPower_Toggle")

local JumpPowerSlider = CharacterGroupbox:CreateSlider({
    Name = "JumpPower", Icon = NebulaIcons:GetIcon('arrow-big-up-dash', 'Lucide'),
    Range = {0, 500}, Increment = 1, CurrentValue = Main.JumpPower or 50,
    Callback = function(Value)
        Main.JumpPower = Value
        if Main.JumpPowerEnabled then
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
        end
    end
}, "JumpPower_Slider")

local NoClipToggle = CharacterGroupbox:CreateToggle({
    Name = "NoClip Enabled", CurrentValue = false, Style = 2,
    Callback = function(Value)
        Main.NoClipEnabled = Value
        if Value then
            ClippingParts = {}
            local function NoclipLoop()
                if Main.NoClipEnabled == true and Player.Character ~= nil then
                    for _, child in pairs(Player.Character:GetDescendants()) do
                        if child:IsA("BasePart") and child.CanCollide == true then
                            child.CanCollide = false
                            if not table.find(ClippingParts, child) then
                                table.insert(ClippingParts, child)
                            end
                        end
                    end
                end
            end
            Noclipping = RunService.Stepped:Connect(NoclipLoop)
        else
            if Noclipping ~= nil then
                Noclipping:Disconnect()
                Noclipping = nil
            end
            for _, part in pairs(ClippingParts) do
                if part and part.Parent then part.CanCollide = true end
            end
            ClippingParts = {}
        end
    end
}, "NoClip_Toggle")

local GravityToggle = EnvironmentGroupbox:CreateToggle({
    Name = "Gravity Enabled", CurrentValue = true, Style = 2,
    Callback = function(Value)
        Main.GravityEnabled = Value
        if Value then
            workspace.Gravity = Main.Gravity
        else
            workspace.Gravity = 196.2 
        end
    end
}, "Gravity_Toggle")

local GravitySlider = EnvironmentGroupbox:CreateSlider({
    Name = "Gravity", Icon = NebulaIcons:GetIcon('earth', 'Lucide'),
    Range = {0, 500}, Increment = 0.1, CurrentValue = Main.Gravity or 196.2,
    Callback = function(Value)
        Main.Gravity = Value
        if Main.GravityEnabled then
           workspace.Gravity = Value
        end
    end
}, "Gravity_Slider")

-- Aimbot Settings
local AimbotToggle = AimbotSettingsGroupbox:CreateToggle({
    Name = "Enabled", CurrentValue = false, Style = 2,
    Callback = function(Value) Aimbot.Enabled = Value end
}, "Aimbot_Toggle")

AimbotSettingsGroupbox:CreateToggle({
    Name = "Team Check", CurrentValue = false, Style = 2,
    Callback = function(v) Aimbot.TeamCheck = v end
})

AimbotSettingsGroupbox:CreateToggle({
    Name = "Visible Check", CurrentValue = true, Style = 2,
    Callback = function(v) Aimbot.VisibleCheck = v end
})

local TargetPartLabel = AimbotSettingsGroupbox:CreateLabel({ Name = "Target Part" }, "TargetPart_Label")
local TargetPartDropdown = TargetPartLabel:AddDropdown({
    Options = {"Head", "HumanoidRootPart", "Torso", "Right Arm", "Left Arm", "Right Leg", "Left Leg", "Legit"},
    CurrentOption = {"Head"}, MultipleOptions = false,
    Callback = function(Options) Aimbot.TargetPart = AimbotTargetPart[Options[1]] end,
}, "TargetPart_Dropdown")

local FOVCircle = Drawing.new("Circle")
FOVCircle.Color = Color3.new(1, 1, 1)
FOVCircle.Visible = Aimbot.FOVCircle
FOVCircle.Filled = false
FOVCircle.Thickness = 1
FOVCircle.NumSides = 90

local function updateCircle()
    local mouseLoc = UserInputService:GetMouseLocation()
    local corrected = Vector2.new(mouseLoc.X, mouseLoc.Y)
    FOVCircle.Position = corrected
end

local circleUpdates = nil
local FOVCircleToggle = AimbotSettingsGroupbox:CreateToggle({
    Name = "FOV Circle", CurrentValue = true, Style = 2,
    Callback = function(Value)
        Aimbot.FOVCircle = Value
        if Value then
            FOVCircle.Visible = true
            circleUpdates = RunService.Heartbeat:Connect(updateCircle)
        else
            FOVCircle.Visible = false
            if circleUpdates then
                circleUpdates:Disconnect()
                circleUpdates = nil
            end
        end
    end
}, "FOVCircle_Toggle")

local FOVSlider = AimbotSettingsGroupbox:CreateSlider({
    Name = "FOV", Icon = NebulaIcons:GetIcon('radius', 'Lucide'),
    Range = {0, 1000}, Increment = 1, CurrentValue = Aimbot.FOV or 150,
    Callback = function(Value)
        Aimbot.FOV = Value
        if Aimbot.FOVCircle then FOVCircle.Radius = Value end
    end
}, "FOV_Slider")

local RangeSlider = AimbotSettingsGroupbox:CreateSlider({
    Name = "Range", Icon = NebulaIcons:GetIcon('binoculars', 'Lucide'),
    Range = {0, 10000}, Increment = 1, CurrentValue = Aimbot.Range or 1000,
    Callback = function(Value) Aimbot.Range = Value end
}, "Range_Slider")

local SmoothnessSlider = AimbotSettingsGroupbox:CreateSlider({
    Name = "Smoothness", Icon = NebulaIcons:GetIcon('chart-spline', 'Lucide'),
    Range = {0.1, 1}, Increment = 0.05, CurrentValue = Aimbot.Smoothness or 0.5,
    Callback = function(Value) Aimbot.Smoothness = Value end
}, "Smoothness_Slider")

local FilteringLabel = AimbotSettingsGroupbox:CreateLabel({ Name = "Filtering" }, "Filtering_Label")
local FilteringDropdown = FilteringLabel:AddDropdown({
    Options = {"ClosestToMouse", "ClosestToPlayer", "LowestHealth"},
    CurrentOption = {"ClosestToMouse"}, MultipleOptions = false,
    Callback = function(Options) Aimbot.Filtering = AimbotFiltering[Options[1]] end,
}, "Filtering_Dropdown")

AimbotSettingsGroupbox:CreateKeybind({
    Name = "Aimbot Keybind", CurrentKeybind = "MouseButton2", HoldToInteract = true,
    Callback = function(key) 
        if typeof(key) == "EnumItem" then
            Aimbot.Keybind = key.Name
        elseif type(key) == "string" then
            Aimbot.Keybind = key
        end
    end
})

local PredictionToggle = PredictionSettingsGroupbox:CreateToggle({
    Name = "Prediction", CurrentValue = false, Style = 2,
    Callback = function(Value) Aimbot.Prediction = Value end
}, "Prediction_Toggle")

local BulletSpeedSlider = PredictionSettingsGroupbox:CreateSlider({
    Name = "Bullet Speed", Icon = NebulaIcons:GetIcon('gauge', 'Lucide'),
    Range = {10, 10000}, Increment = 10, CurrentValue = Aimbot.BulletSpeed or 1500,
    Callback = function(Value) Aimbot.BulletSpeed = Value end
}, "BulletSpeed_Slider")

local BulletDropToggle = PredictionSettingsGroupbox:CreateToggle({
    Name = "Bullet Drop", CurrentValue = false, Style = 2,
    Callback = function(Value) Aimbot.BulletDrop = Value end
}, "BulletDrop_Toggle")

local BulletDropSlider = PredictionSettingsGroupbox:CreateSlider({
    Name = "Drop Amount", Icon = NebulaIcons:GetIcon('arrow-down-to-line', 'Lucide'),
    Range = {1, 200}, Increment = 1, CurrentValue = Aimbot.BulletDropAmount or 50,
    Callback = function(Value) Aimbot.BulletDropAmount = Value end
}, "BulletDrop_Slider")

PredictionSettingsGroupbox:CreateToggle({
    Name = "Show Projectile Path", CurrentValue = false, Style = 2,
    Callback = function(v) 
        Aimbot.Visualizer = v 
        if not v then for _, l in pairs(VisualizerLines) do l.Visible = false end end
    end
})

-- Combat & Calibration
WeaponGroup:CreateToggle({ Name = "Triggerbot", Style = 2, Callback = function(v) Combat.Triggerbot = v end })
WeaponGroup:CreateSlider({ Name = "Trigger Delay", Range = {0, 1}, Increment = 0.01, CurrentValue = 0.05, Callback = function(v) Combat.TriggerDelay = v end })
WeaponGroup:CreateToggle({ Name = "No Recoil", Style = 2, Callback = function(v) Combat.NoRecoil = v end })

local PlayerList = {"None"}
for _, p in pairs(Players:GetPlayers()) do if p ~= Player then table.insert(PlayerList, p.Name) end end
local TargetDropdown = CombatGroup:CreateDropdown({
    Name = "Calibration Target", Options = PlayerList, CurrentOption = "None",
    Callback = function(val) CalibrationTarget = Players:FindFirstChild(val[1] or val) end
})

Players.PlayerAdded:Connect(function(p)
    if p ~= Player then table.insert(PlayerList, p.Name); pcall(function() TargetDropdown:SetValues(PlayerList) end) end
end)
Players.PlayerRemoving:Connect(function(p)
    for i, name in ipairs(PlayerList) do 
        if name == p.Name then 
            table.remove(PlayerList, i)
            pcall(function() TargetDropdown:SetValues(PlayerList) end) 
            break 
        end 
    end
end)

CombatGroup:CreateButton({ Name = "Calibrate Speed", Callback = function()
    if CalibrationLock or not CalibrationTarget or not CalibrationTarget.Character or not CalibrationTarget.Character:FindFirstChild("Humanoid") then return end
    CalibrationLock = true
    local char = CalibrationTarget.Character
    local targetPart = char:FindFirstChild(Aimbot.TargetPart) or char:FindFirstChild("HumanoidRootPart")
    workspace.CurrentCamera.CFrame = CFrame.lookAt(workspace.CurrentCamera.CFrame.Position, targetPart.Position)
    local initialHealth, startTime, distance = char.Humanoid.Health, os.clock(), (targetPart.Position - workspace.CurrentCamera.CFrame.Position).Magnitude
    
    mouse1click()

    task.spawn(function()
        local success = false
        while os.clock() - startTime < 2 do
            if char.Humanoid.Health < initialHealth then
                Aimbot.BulletSpeed = math.floor(distance / (os.clock() - startTime))
                BulletSpeedSlider:Set(Aimbot.BulletSpeed)
                Starlight:Notification({ Title = "Success", Content = "Speed set to: " .. Aimbot.BulletSpeed, Duration = 3 })
                success = true break
            end
            task.wait()
        end
        if not success then Starlight:Notification({ Title = "Error", Content = "No hit detected.", Duration = 3 }) end
        CalibrationLock = false
    end)
end})

CombatGroup:CreateButton({ Name = "Calibrate Drop", Callback = function()
    if CalibrationLock or not CalibrationTarget or not CalibrationTarget.Character or not CalibrationTarget.Character:FindFirstChild("Humanoid") then return end
    CalibrationLock = true
    local char = CalibrationTarget.Character
    local targetPart = char:FindFirstChild(Aimbot.TargetPart) or char:FindFirstChild("HumanoidRootPart")
    workspace.CurrentCamera.CFrame = CFrame.lookAt(workspace.CurrentCamera.CFrame.Position, targetPart.Position)
    local initialHealth, startTime = char.Humanoid.Health, os.clock()
    
    mouse1click()

    task.spawn(function()
        while os.clock() - startTime < 2 do
            if char.Humanoid.Health < initialHealth then
                local t = os.clock() - startTime
                if t > 0 then
                    Aimbot.BulletDropAmount = math.floor((2 * 50) / (t^2))
                    BulletDropSlider:Set(Aimbot.BulletDropAmount)
                    Starlight:Notification({ Title = "Success", Content = "Drop Factor Adjusted.", Duration = 3 })
                end
                break
            end
            task.wait()
        end
        CalibrationLock = false
    end)
end})

-- Cached Friends System
local friendCache = {}
local function isPlayerFriend(targetPlayer)
    if friendCache[targetPlayer.UserId] ~= nil then return friendCache[targetPlayer.UserId] end
    friendCache[targetPlayer.UserId] = false
    task.spawn(function()
        local success, result = pcall(function() return Player:IsFriendsWith(targetPlayer.UserId) end)
        if success then friendCache[targetPlayer.UserId] = result end
    end)
    return friendCache[targetPlayer.UserId]
end

local function getColorForPlayer(player)
    if Visuals.UseTeamColor and player.Team then return player.TeamColor.Color end
    local baseColor = Visuals.Rainbow and Visuals.CurrentColor or Color3.new(1, 1, 1)
    if Visuals.InverseFriends and isPlayerFriend(player) then
        local h, s, v = baseColor:ToHSV()
        return Color3.fromHSV((h + 0.5) % 1, s, v) 
    else
        return baseColor
    end
end

local function createESP(player)
    if not player.Character then return end
    if not espFolder:FindFirstChild(player.Name .. "_ESP") then
        local espObject = Instance.new("Highlight")
        espObject.Name = player.Name .. "_ESP"
        espObject.Parent = espFolder
        espObject.Adornee = player.Character
        espObject.FillTransparency = 1
        espObject.OutlineColor = getColorForPlayer(player)
        espObject.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    else
        espFolder[player.Name .. "_ESP"].Adornee = player.Character
    end
end

local function addESP()
    for _, player in pairs(Players:GetPlayers()) do createESP(player) end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        if Visuals.ESP then createESP(player) end
    end)
end)

for _, player in pairs(Players:GetPlayers()) do
    player.CharacterAdded:Connect(function()
        if Visuals.ESP then createESP(player) end
    end)
end

local ESPToggle = ESPSettingsGroupbox:CreateToggle({
    Name = "Enabled", CurrentValue = false, Style = 2,
    Callback = function(Value)
        Visuals.ESP = Value
        if Value then addESP() else espFolder:ClearAllChildren() end
    end
}, "ESP_Toggle")

local TracersToggle = ESPSettingsGroupbox:CreateToggle({
    Name = "Tracers", CurrentValue = false, Style = 2,
    Callback = function(Value) Visuals.Tracers = Value end
}, "Tracers_Toggle")

local UseTeamColorToggle = ESPSettingsGroupbox:CreateToggle({
    Name = "Use Team Color", CurrentValue = false, Style = 2,
    Callback = function(Value) Visuals.UseTeamColor = Value end
})

local RainbowToggle = ESPSettingsGroupbox:CreateToggle({
    Name = "Rainbow", CurrentValue = false, Style = 2,
    Callback = function(Value)
        Visuals.Rainbow = Value
        if Value then
            local function doRainbow()
                local time = os.clock() 
                local hue = (time * 0.2) % 1 
                Visuals.CurrentColor = Color3.fromHSV(hue, 1, 1)
            end
            rainbowing = RunService.RenderStepped:Connect(doRainbow)
        else
            Visuals.CurrentColor = Color3.new(1, 1, 1)
            if rainbowing then
                rainbowing:Disconnect()
                rainbowing = nil
            end
        end
    end
}, "Rainbow_Toggle")

local InverseFriendsToggle = ESPSettingsGroupbox:CreateToggle({
    Name = "Inverse Friends", CurrentValue = false, Style = 2,
    Callback = function(Value) Visuals.InverseFriends = Value end
}, "InverseFriends_Toggle")


-- Settings & Configs
SettingsTab:BuildConfigGroupbox(1)
local ThemeGroup = SettingsTab:CreateGroupbox({ Name = "Theme Manager", Column = 2 })
ThemeGroup:CreateColorpicker({
    Name = "UI Accent Color", DefaultColor = Color3.fromRGB(170, 85, 255),
    Callback = function(color) Starlight:SetThemeColor(color) end
})


-- Credits
local CreditsLabel = CreditsGroupbox:CreateLabel({
    Name = "Credits:", Content = "Script made by Sporer66846\nUI Library made by Nebula Softworks\nVersion 1.0",
}, "Creator_Label")

local CopyBitcoinButton = DonateGroupbox:CreateButton({
    Name = "Copy Bitcoin Wallet", Icon = NebulaIcons:GetIcon('bitcoin', 'Lucide'), Style = 1,
    Callback = function() setclipboard("bc1q54wdp3xrhmrpcqnlqf72rlmmjg7c83fj30n43u") end,
}, "CopyBitcoin_Button")

local CopyEtheriumButton = DonateGroupbox:CreateButton({
    Name = "Copy Etherium Wallet", Icon = NebulaIcons:GetIcon('gpu', 'Lucide'), Style = 1,
    Callback = function() setclipboard("0x75BbcC2aaEdef8d5205c0B6DFCa85c20C9aE608A") end,
}, "CopyEtherium_Button")

local CopyDiscordButton = SocialsGroupbox:CreateButton({
    Name = "Copy Discord Link", Icon = NebulaIcons:GetIcon('bot', 'Lucide'), Style = 1,
    Callback = function() setclipboard("https://discord.gg/CSzZPNwUWY") end,
}, "CopyDiscord_Button")


-- Helper: Convert world position to screen position
local function worldToScreen(pos)
    local camera = workspace.CurrentCamera
    local screenPos, onScreen = camera:WorldToViewportPoint(pos)
    return Vector2.new(screenPos.X, screenPos.Y), onScreen
end

local function IsVisible(part)
    if not Aimbot.VisibleCheck then return true end
    local char = Player.Character
    if not char then return false end
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {char}
    
    local dir = (part.Position - workspace.CurrentCamera.CFrame.Position)
    local result = workspace:Raycast(workspace.CurrentCamera.CFrame.Position, dir, params)
    
    if result then
        if result.Instance:IsDescendantOf(part.Parent) then return true end
        return false
    end
    return true
end


Players.PlayerRemoving:Connect(function(player)
    if ESPDrawings[player] then
        ESPDrawings[player].Tracer:Remove()
        ESPDrawings[player].NameText:Remove()
        ESPDrawings[player] = nil
    end
    local hl = espFolder:FindFirstChild(player.Name .. "_ESP")
    if hl then hl:Destroy() end
end)


-- Combat Functions
RunService.Heartbeat:Connect(function()
    if Combat.Triggerbot then
        local mouseLoc = UserInputService:GetMouseLocation()
        local ray = workspace.CurrentCamera:ViewportPointToRay(mouseLoc.X, mouseLoc.Y)
        local result = workspace:Raycast(ray.Origin, ray.Direction * 1000)
        if result and result.Instance and result.Instance.Parent:FindFirstChild("Humanoid") then
            local hitPlayer = Players:GetPlayerFromCharacter(result.Instance.Parent)
            if hitPlayer and hitPlayer ~= Player then
                if Aimbot.TeamCheck and hitPlayer.Team == Player.Team then return end
                task.wait(Combat.TriggerDelay)
                mouse1click()
            end
        end
    end
end)

local LastCameraRotation = workspace.CurrentCamera.CFrame
RunService.RenderStepped:Connect(function()
    if Combat.NoRecoil then
        if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then 
            workspace.CurrentCamera.CFrame = LastCameraRotation 
        end
        LastCameraRotation = workspace.CurrentCamera.CFrame
    else 
        LastCameraRotation = workspace.CurrentCamera.CFrame 
    end
end)

local function UpdateVisualizer()
    if not Aimbot.Visualizer then return end
    local startPos = workspace.CurrentCamera.CFrame.Position
    local startVel = workspace.CurrentCamera.CFrame.LookVector * Aimbot.BulletSpeed
    local gravity = Vector3.new(0, -Aimbot.BulletDropAmount, 0)
    for i = 1, 20 do
        if not VisualizerLines[i] then 
            VisualizerLines[i] = Drawing.new("Line"); VisualizerLines[i].Thickness = 1.5; VisualizerLines[i].Color = Color3.new(0, 1, 0) 
        end
        local t1, t2 = (i - 1) * 0.1, i * 0.1
        local p1 = startPos + (startVel * t1) + (0.5 * gravity * t1^2)
        local p2 = startPos + (startVel * t2) + (0.5 * gravity * t2^2)
        local screenPos1, on1 = workspace.CurrentCamera:WorldToViewportPoint(p1)
        local screenPos2, on2 = workspace.CurrentCamera:WorldToViewportPoint(p2)
        if on1 and on2 then
            VisualizerLines[i].From = Vector2.new(screenPos1.X, screenPos1.Y)
            VisualizerLines[i].To = Vector2.new(screenPos2.X, screenPos2.Y)
            VisualizerLines[i].Visible = true
        else VisualizerLines[i].Visible = false end
    end
end

RunService.RenderStepped:Connect(function()
    UpdateVisualizer()

    local camera = workspace.CurrentCamera
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Player then
            if not ESPDrawings[player] then
                ESPDrawings[player] = {
                    Tracer = Drawing.new("Line"),
                    NameText = Drawing.new("Text")
                }
            end

            local tracer = ESPDrawings[player].Tracer
            local nameText = ESPDrawings[player].NameText
            tracer.Visible = false
            nameText.Visible = false

            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local char = player.Character
                local hrp = char:FindFirstChild("HumanoidRootPart")
                local head = char:FindFirstChild("Head")
                local humanoid = char:FindFirstChild("Humanoid")
                
                if humanoid and humanoid.Health > 0 then
                    local colorToUse = (Target == player) and Color3.new(1, 0, 0) or getColorForPlayer(player)

                    if Visuals.ESP then
                        local espObj = espFolder:FindFirstChild(player.Name .. "_ESP")
                        if espObj then espObj.OutlineColor = colorToUse end
                    end

                    if Visuals.Tracers and hrp then
                        local screenPos, onScreen = worldToScreen(hrp.Position)
                        if onScreen then
                            tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y) 
                            tracer.To = screenPos
                            tracer.Color = colorToUse
                            tracer.Thickness = 1.5
                            tracer.Transparency = 1
                            tracer.Visible = true
                        end
                    end

                    if Visuals.ESP and head then
                        local namePos, onScreen = worldToScreen(head.Position + Vector3.new(0, 3, 0))
                        if onScreen then
                            local txt = player.Name
                            if isPlayerFriend(player) then txt = "(Friend) " .. txt end
                            nameText.Text = txt
                            nameText.Position = namePos
                            nameText.Size = 14
                            nameText.Color = colorToUse
                            nameText.Center = true
                            nameText.Outline = true
                            nameText.OutlineColor = Color3.new(0, 0, 0)
                            nameText.Visible = true
                        end
                    end
                end
            end
        end
    end
end)


local function ReturnPlayers()
    local PlayersTable = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if not table.find(PlayersTable, player) then
            table.insert(PlayersTable, player)
        end
    end
    return PlayersTable
end

local function GetPlayerDistance(targetPlayer)
    local targetCharacter = targetPlayer.Character
    if not targetCharacter then return end
    local targetHumanoidRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")

    local Character = Player.Character
    if not Character then return end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")

    if not targetHumanoidRootPart or not HumanoidRootPart then return end
    return (targetHumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
end

local function GetMouseDistanceToPlayer(player)
    local camera = workspace.CurrentCamera
    local char = player.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return math.huge end

    local screenPoint, onScreen = camera:WorldToScreenPoint(root.Position)
    if screenPoint.Z <= 0 then return math.huge end

    local mouseLoc = UserInputService:GetMouseLocation()
    local dx = screenPoint.X - mouseLoc.X
    local dy = screenPoint.Y - mouseLoc.Y
    return math.sqrt(dx*dx + dy*dy)
end

local function ValidTargetCheck(player)
    if player == Player then return false end
    if Aimbot.TeamCheck and player.Team == Player.Team then return false end
    local char = player.Character
    if not char then return false end
    local hum = char:FindFirstChild("Humanoid")
    if not hum or hum.Health <= 0 then return false end
    
    local targetPartName = Aimbot.TargetPart == "Legit" and "Head" or Aimbot.TargetPart
    local part = char:FindFirstChild(targetPartName) or char:FindFirstChild("HumanoidRootPart")
    if not part then return false end
    
    return IsVisible(part)
end

local function GetClosestToMouse(playerList)
    local closestPlayer    = nil
    local shortestDistance = Aimbot.FOV

    for _, player in ipairs(playerList) do
        if ValidTargetCheck(player) then
            local dist2d = GetMouseDistanceToPlayer(player)
            if dist2d and dist2d < shortestDistance then
                local pDist = GetPlayerDistance(player)
                if pDist and pDist <= Aimbot.Range then
                    shortestDistance = dist2d
                    closestPlayer    = player
                end
            end
        end
    end
    return closestPlayer
end

local function GetClosestToPlayer(PlayersTable)
    local closestPlayer = nil
    local shortestDistance = Aimbot.Range
    
    for _, player in ipairs(PlayersTable) do
        if ValidTargetCheck(player) then
            local dist = GetPlayerDistance(player)
            local checkFOV = (GetMouseDistanceToPlayer(player) < Aimbot.FOV)
            if dist and dist < shortestDistance and checkFOV then
                closestPlayer = player
                shortestDistance = dist
            end
        end
    end
    return closestPlayer
end

local function GetLowestHealth(PlayersTable)
    local lowestPlayer = nil
    local lowestHealth = math.huge
    local shortestDistance = Aimbot.Range

     for _, player in ipairs(PlayersTable) do
        if ValidTargetCheck(player) then
            local char = player.Character
            local humanoid = char:FindFirstChild("Humanoid")
            local dist = GetPlayerDistance(player)
            local checkFOV = (GetMouseDistanceToPlayer(player) < Aimbot.FOV)
            if dist and humanoid.Health < lowestHealth and dist < shortestDistance and checkFOV then
                lowestPlayer = player
                lowestHealth = humanoid.Health
            end
        end
    end
    return lowestPlayer
end


local function lookAtPosition(camera, position, dt)
    local newCFrame = CFrame.lookAt(camera.CFrame.Position, position)
    local alpha = 1 - math.pow(1 - Aimbot.Smoothness, dt * 60)
    camera.CFrame = camera.CFrame:Lerp(newCFrame, math.clamp(alpha, 0, 1))
end

local function aimbotKeyDown()
    if Aimbot.Enabled == false then return end

    if Aimbotting then Aimbotting:Disconnect() Aimbotting = nil end

    local currentPlayerTable = ReturnPlayers()

    if currentPlayerTable ~= nil and #currentPlayerTable > 0 then
        if Aimbot.Filtering == AimbotFiltering.ClosestToMouse then
            Target = GetClosestToMouse(currentPlayerTable)
        elseif Aimbot.Filtering == AimbotFiltering.ClosestToPlayer then
            Target = GetClosestToPlayer(currentPlayerTable)
        elseif Aimbot.Filtering == AimbotFiltering.LowestHealth then
            Target = GetLowestHealth(currentPlayerTable)
        end
    end

    if Target == nil then return end

    local character = Target.Character
    if not character then return end

    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end

    local isR6 = (humanoid.RigType == Enum.HumanoidRigType.R6)
    local mapping = {
        Head               = "Head",
        HumanoidRootPart   = "HumanoidRootPart",
        Torso              = isR6 and "Torso"           or "UpperTorso",
        ["Right Arm"]      = isR6 and "Right Arm"       or "RightUpperArm",
        ["Left Arm"]       = isR6 and "Left Arm"        or "LeftUpperArm",
        ["Right Leg"]      = isR6 and "Right Leg"       or "RightUpperLeg",
        ["Left Leg"]       = isR6 and "Left Leg"        or "LeftUpperLeg",
    }

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        warn("No HumanoidRootPart! Can't fall back safely.")
        return
    end

    local bodyParts = {}
    for key, childName in pairs(mapping) do
        if key == "HumanoidRootPart" then
            bodyParts[key] = rootPart
        else
            bodyParts[key] = character:FindFirstChild(childName) or rootPart
        end
    end

    local camera = workspace.CurrentCamera
    local switchInterval  = 0.3
    local lastSwitchTime  = 0
    local currentPart     = nil

    local function ManipulateCamera(deltaTime)
        if not Target or not Target.Character or not Target.Character:FindFirstChild("Humanoid") or Target.Character.Humanoid.Health <= 0 then
            if Aimbotting then Aimbotting:Disconnect() Aimbotting = nil end
            Target = nil
            return
        end

        local position

        if Aimbot.TargetPart ~= AimbotTargetPart.Legit then
            position = bodyParts[Aimbot.TargetPart].Position
            currentPart = nil
            lastSwitchTime = time()
        else
            local now = time()
            if not currentPart or now - lastSwitchTime >= switchInterval then
                lastSwitchTime = now
                local count = 0
                for _, part in pairs(bodyParts) do
                    count = count + 1
                    if math.random(count) == 1 then
                        currentPart = part
                    end
                end
            end
            position = currentPart.Position
        end

        if Aimbot.Prediction and Aimbot.BulletSpeed > 0 then
            local distance = (position - camera.CFrame.Position).Magnitude
            local bulletTravelTime = distance / Aimbot.BulletSpeed

            if rootPart then
                position = position + rootPart.Velocity * bulletTravelTime
            end

            if Aimbot.BulletDrop and Aimbot.BulletDropAmount > 0 then
                local drop = 0.5 * Aimbot.BulletDropAmount * bulletTravelTime^2
                position = Vector3.new(position.X, position.Y + drop, position.Z)
            end
        end

        lookAtPosition(camera, position, deltaTime)
    end

    Aimbotting = RunService.RenderStepped:Connect(ManipulateCamera)
end

local function aimbotKeyUp()
    if Aimbotting ~= nil then
        Aimbotting:Disconnect()
        Aimbotting = nil
    end
    Target = nil
end

local function inputDown(input, gameprocessed)
    if gameprocessed then return end
    local keyName = (input.UserInputType == Enum.UserInputType.Keyboard) and input.KeyCode.Name or input.UserInputType.Name
    if keyName == Aimbot.Keybind then
        aimbotKeyDown()
    end
end

local function inputUp(input, gameprocessed)
    local keyName = (input.UserInputType == Enum.UserInputType.Keyboard) and input.KeyCode.Name or input.UserInputType.Name
    if keyName == Aimbot.Keybind then
        aimbotKeyUp()
    end
end

UserInputService.InputBegan:Connect(inputDown)
UserInputService.InputEnded:Connect(inputUp)

Starlight:LoadAutoloadConfig()

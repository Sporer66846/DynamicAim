getgenv().SecureMode = true

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local Starlight = loadstring(game:HttpGet("https://raw.nebulasoftworks.xyz/starlight"))()  
local NebulaIcons = loadstring(game:HttpGet("https://raw.nebulasoftworks.xyz/nebula-icon-library-loader"))()

local Player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local espFolder = Instance.new("Folder")
espFolder.Parent = gethui()

-- Logic Variables
local ESPDrawings = {}
local VisualizerLines = {}
local Target = nil
local CalibrationTarget = nil
local AimbotConnection = nil
local RainbowConnection = nil
local Noclipping = nil
local ClippingParts = {}
local CalibrationLock = false

-- State Tables
local Main = {
    WalkSpeedEnabled = false, WalkSpeed = 16,
    JumpPowerEnabled = false, JumpPower = 50,
    NoClipEnabled = false, GravityEnabled = false, Gravity = 196.2
}

local AimbotTargetPart = {
    Head = "Head", HumanoidRootPart = "HumanoidRootPart", Torso = "Torso",
    ["Right Arm"] = "Right Arm", ["Left Arm"] = "Left Arm",
    ["Right Leg"] = "Right Leg", ["Left Leg"] = "Left Leg", Legit = "Legit"
}

local Aimbot = {
    Enabled = false, TeamCheck = false, VisibleCheck = true,
    TargetPart = "Head", FOVCircle = true, FOV = 150,
    Range = 1000, Smoothness = 0.5, Filtering = "ClosestToMouse",
    Prediction = true, BulletSpeed = 1500, BulletDrop = true, BulletDropAmount = 50,
    Keybind = "MouseButton2", Visualizer = false
}

local Combat = {
    Triggerbot = false, TriggerDelay = 0.05, NoRecoil = false
}

local Visuals = {
    ESP = false, Tracers = true, UseTeamColor = false,
    Rainbow = false, InverseFriends = false, CurrentColor = Color3.new(1, 1, 1)
}

-- Window Setup
local Window = Starlight:CreateWindow({
    Name = "Dynamic Aim V3",
    Subtitle = "Precision Combat Suite",
    Icon = 110782178856576,
    ConfigurationSettings = { FolderName = "DynamicAimConfigs" }
})

local MainSection = Window:CreateTabSection("Main")
local SettingsSection = Window:CreateTabSection("Miscellaneous")

local HomeTab = MainSection:CreateTab({ Name = "Home", Icon = NebulaIcons:GetIcon('home', 'Lucide'), Columns = 2 })
local AimbotTab = MainSection:CreateTab({ Name = "Aimbot", Icon = NebulaIcons:GetIcon('mouse', 'Lucide'), Columns = 2 })
local CombatTab = MainSection:CreateTab({ Name = "Combat", Icon = NebulaIcons:GetIcon('swords', 'Lucide'), Columns = 2 })
local VisualsTab = MainSection:CreateTab({ Name = "Visuals", Icon = NebulaIcons:GetIcon('eye', 'Lucide'), Columns = 1 })
local SettingsTab = SettingsSection:CreateTab({ Name = "Settings", Icon = NebulaIcons:GetIcon('settings', 'Lucide'), Columns = 2 })
local CreditsTab = SettingsSection:CreateTab({ Name = "Credits", Icon = NebulaIcons:GetIcon('info', 'Lucide'), Columns = 3 })

-- FOV Circle Drawing
local FOVCircleDrawing = Drawing.new("Circle")
FOVCircleDrawing.Color = Color3.new(1, 1, 1)
FOVCircleDrawing.Filled = false
FOVCircleDrawing.Thickness = 1
FOVCircleDrawing.NumSides = 90
FOVCircleDrawing.Visible = false

RunService.Heartbeat:Connect(function()
    FOVCircleDrawing.Visible = (Aimbot.Enabled and Aimbot.FOVCircle)
    if FOVCircleDrawing.Visible then
        FOVCircleDrawing.Position = UserInputService:GetMouseLocation()
        FOVCircleDrawing.Radius = Aimbot.FOV
    end
end)

-- UI Elements: Home (Restored JumpPower and NoClip)
local CharGroup = HomeTab:CreateGroupbox({ Name = "Character", Column = 1 })
CharGroup:CreateToggle({ Name = "WalkSpeed Enabled", Callback = function(v) 
    Main.WalkSpeedEnabled = v 
    if not v and Player.Character and Player.Character:FindFirstChild("Humanoid") then Player.Character.Humanoid.WalkSpeed = 16 end
end })
CharGroup:CreateSlider({ Name = "WalkSpeed", Range = {0, 500}, Increment = 1, CurrentValue = 16, Callback = function(v) Main.WalkSpeed = v end })

CharGroup:CreateToggle({ Name = "JumpPower Enabled", Callback = function(v) 
    Main.JumpPowerEnabled = v 
    if not v and Player.Character and Player.Character:FindFirstChild("Humanoid") then Player.Character.Humanoid.JumpPower = 50 end
end })
CharGroup:CreateSlider({ Name = "JumpPower", Range = {0, 500}, Increment = 1, CurrentValue = 50, Callback = function(v) Main.JumpPower = v end })

CharGroup:CreateToggle({ Name = "NoClip Enabled", Callback = function(v)
    Main.NoClipEnabled = v
    if v then
        ClippingParts = {}
        Noclipping = RunService.Stepped:Connect(function()
            if Player.Character then
                for _, child in pairs(Player.Character:GetDescendants()) do
                    if child:IsA("BasePart") and child.CanCollide then
                        child.CanCollide = false
                        if not table.find(ClippingParts, child) then table.insert(ClippingParts, child) end
                    end
                end
            end
        end)
    else
        if Noclipping then Noclipping:Disconnect() Noclipping = nil end
        for _, part in pairs(ClippingParts) do if part and part.Parent then part.CanCollide = true end end
        ClippingParts = {}
    end
end })

local EnvGroup = HomeTab:CreateGroupbox({ Name = "Environment", Column = 2 })
EnvGroup:CreateToggle({ Name = "Gravity Enabled", Callback = function(v) 
    Main.GravityEnabled = v 
    workspace.Gravity = v and Main.Gravity or 196.2
end })
EnvGroup:CreateSlider({ Name = "Gravity", Range = {0, 500}, Increment = 0.1, CurrentValue = 196.2, Callback = function(v) Main.Gravity = v end })

-- UI Elements: Aimbot Settings (Restored Filtering and Target Part)
local AimGroup = AimbotTab:CreateGroupbox({ Name = "Aimbot Settings", Column = 1 })
AimGroup:CreateToggle({ Name = "Enabled", Callback = function(v) Aimbot.Enabled = v end })
AimGroup:CreateToggle({ Name = "Team Check", Callback = function(v) Aimbot.TeamCheck = v end })
AimGroup:CreateToggle({ Name = "Visible Check", CurrentValue = true, Callback = function(v) Aimbot.VisibleCheck = v end })

local TargetPartLabel = AimGroup:CreateLabel({ Name = "Target Part" })
TargetPartLabel:AddDropdown({
    Options = {"Head", "HumanoidRootPart", "Torso", "Right Arm", "Left Arm", "Right Leg", "Left Leg", "Legit"},
    CurrentOption = {"Head"}, MultipleOptions = false,
    Callback = function(Options) Aimbot.TargetPart = AimbotTargetPart[Options[1]] end,
})

local FilterLabel = AimGroup:CreateLabel({ Name = "Filtering" })
FilterLabel:AddDropdown({
    Options = {"ClosestToMouse", "ClosestToPlayer", "LowestHealth"},
    CurrentOption = {"ClosestToMouse"}, MultipleOptions = false,
    Callback = function(Options) Aimbot.Filtering = Options[1] end,
})

AimGroup:CreateToggle({ Name = "FOV Circle", CurrentValue = true, Callback = function(v) Aimbot.FOVCircle = v end })
AimGroup:CreateSlider({ Name = "FOV Radius", Range = {0, 1000}, Increment = 1, CurrentValue = 150, Callback = function(v) Aimbot.FOV = v end })
AimGroup:CreateSlider({ Name = "Target Range", Range = {0, 10000}, Increment = 1, CurrentValue = 1000, Callback = function(v) Aimbot.Range = v end })
AimGroup:CreateSlider({ Name = "Smoothness", Range = {0.1, 1}, Increment = 0.05, CurrentValue = 0.5, Callback = function(v) Aimbot.Smoothness = v end })
AimGroup:CreateKeybind({
    Name = "Aimbot Key", CurrentKeybind = "MouseButton2", HoldToInteract = true,
    Callback = function(key) Aimbot.Keybind = typeof(key) == "EnumItem" and key.Name or key end
})

local PredGroup = AimbotTab:CreateGroupbox({ Name = "Prediction Settings", Column = 2 })
PredGroup:CreateToggle({ Name = "Prediction", CurrentValue = true, Callback = function(v) Aimbot.Prediction = v end })
PredGroup:CreateToggle({ Name = "Bullet Drop", CurrentValue = true, Callback = function(v) Aimbot.BulletDrop = v end })
PredGroup:CreateToggle({ Name = "Show Projectile Path", Callback = function(v) 
    Aimbot.Visualizer = v 
    if not v then for _, l in pairs(VisualizerLines) do l.Visible = false end end
end })
local SpeedSlider = PredGroup:CreateSlider({ Name = "Bullet Speed", Range = {10, 10000}, Increment = 10, CurrentValue = 1500, Callback = function(v) Aimbot.BulletSpeed = v end })
local DropSlider = PredGroup:CreateSlider({ Name = "Drop Factor", Range = {0, 500}, Increment = 1, CurrentValue = 50, Callback = function(v) Aimbot.BulletDropAmount = v end })


-- UI Elements: Combat
local CombatGroup = CombatTab:CreateGroupbox({ Name = "Calibration Tools", Column = 1 })
local WeaponGroup = CombatTab:CreateGroupbox({ Name = "Weapon Mods", Column = 2 })

WeaponGroup:CreateToggle({ Name = "Triggerbot", Callback = function(v) Combat.Triggerbot = v end })
WeaponGroup:CreateSlider({ Name = "Trigger Delay", Range = {0, 1}, Increment = 0.01, CurrentValue = 0.05, Callback = function(v) Combat.TriggerDelay = v end })
WeaponGroup:CreateToggle({ Name = "No Recoil", Callback = function(v) Combat.NoRecoil = v end })

local PlayerList = {"None"}
for _, p in pairs(Players:GetPlayers()) do if p ~= Player then table.insert(PlayerList, p.Name) end end
local TargetDropdown = CombatGroup:CreateDropdown({
    Name = "Calibration Target", Options = PlayerList, CurrentOption = "None",
    Callback = function(val) CalibrationTarget = Players:FindFirstChild(val[1] or val) end
})
Players.PlayerAdded:Connect(function(p)
    if p ~= Player then table.insert(PlayerList, p.Name); pcall(function() TargetDropdown:SetValues(PlayerList) end) end
end)
Players.PlayerRemoving:Connect(function(p)
    for i, name in ipairs(PlayerList) do if name == p.Name then table.remove(PlayerList, i); pcall(function() TargetDropdown:SetValues(PlayerList) end); break end end
end)

CombatGroup:CreateButton({ Name = "Calibrate Speed", Callback = function()
    if CalibrationLock or not CalibrationTarget or not CalibrationTarget.Character or not CalibrationTarget.Character:FindFirstChild("Humanoid") then return end
    CalibrationLock = true
    local char = CalibrationTarget.Character
    local targetPart = char:FindFirstChild("HumanoidRootPart")
    camera.CFrame = CFrame.lookAt(camera.CFrame.Position, targetPart.Position)
    local initialHealth, startTime, distance = char.Humanoid.Health, os.clock(), (targetPart.Position - camera.CFrame.Position).Magnitude
    mouse1press() task.wait(0.05) mouse1release()

    task.spawn(function()
        local success = false
        while os.clock() - startTime < 2 do
            if char.Humanoid.Health < initialHealth then
                Aimbot.BulletSpeed = math.floor(distance / (os.clock() - startTime))
                SpeedSlider:Set(Aimbot.BulletSpeed)
                Starlight:Notification({ Title = "Success", Content = "Speed set to: " .. Aimbot.BulletSpeed, Duration = 3 })
                success = true break
            end
            task.wait()
        end
        if not success then Starlight:Notification({ Title = "Error", Content = "No hit detected.", Duration = 3 }) end
        CalibrationLock = false
    end)
end})

CombatGroup:CreateButton({ Name = "Calibrate Drop", Callback = function()
    if CalibrationLock or not CalibrationTarget or not CalibrationTarget.Character or not CalibrationTarget.Character:FindFirstChild("Humanoid") then return end
    CalibrationLock = true
    local char = CalibrationTarget.Character
    local targetPart = char:FindFirstChild("HumanoidRootPart")
    camera.CFrame = CFrame.lookAt(camera.CFrame.Position, targetPart.Position)
    local initialHealth, startTime = char.Humanoid.Health, os.clock()
    mouse1press() task.wait(0.05) mouse1release()

    task.spawn(function()
        while os.clock() - startTime < 2 do
            if char.Humanoid.Health < initialHealth then
                Aimbot.BulletDropAmount = math.floor((2 * 50) / ((os.clock() - startTime)^2))
                DropSlider:Set(Aimbot.BulletDropAmount)
                Starlight:Notification({ Title = "Success", Content = "Drop Factor Adjusted.", Duration = 3 })
                break
            end
            task.wait()
        end
        CalibrationLock = false
    end)
end})

-- UI Elements: Visuals (Restored Inverse Friends)
local ESPSetGroup = VisualsTab:CreateGroupbox({ Name = "ESP Settings", Column = 1 })
ESPSetGroup:CreateToggle({ Name = "Enable ESP", Callback = function(v) Visuals.ESP = v if not v then espFolder:ClearAllChildren() end end })
ESPSetGroup:CreateToggle({ Name = "Tracers", CurrentValue = true, Callback = function(v) Visuals.Tracers = v end })
ESPSetGroup:CreateToggle({ Name = "Use Team Color", Callback = function(v) Visuals.UseTeamColor = v end })
ESPSetGroup:CreateToggle({ Name = "Inverse Friends", Callback = function(v) Visuals.InverseFriends = v end })
ESPSetGroup:CreateToggle({ Name = "Rainbow Mode", Callback = function(v)
    Visuals.Rainbow = v
    if v then RainbowConnection = RunService.RenderStepped:Connect(function() Visuals.CurrentColor = Color3.fromHSV(os.clock() % 5 / 5, 1, 1) end)
    else if RainbowConnection then RainbowConnection:Disconnect() end Visuals.CurrentColor = Color3.new(1, 1, 1) end
end })

-- UI Elements: Config/Themes
SettingsTab:BuildConfigGroupbox(1)
local ThemeGroup = SettingsTab:CreateGroupbox({ Name = "Theme Manager", Column = 2 })
ThemeGroup:CreateColorpicker({ Name = "UI Accent Color", DefaultColor = Color3.fromRGB(170, 85, 255), Callback = function(color) Starlight:SetThemeColor(color) end })

-- UI Elements: Credits (Restored)
local CreditsGroupbox = CreditsTab:CreateGroupbox({ Name = "Credits", Column = 1 })
local DonateGroupbox = CreditsTab:CreateGroupbox({ Name = "Donate", Column = 2 })
local SocialsGroupbox = CreditsTab:CreateGroupbox({ Name = "Socials", Column = 3 })

CreditsGroupbox:CreateLabel({ Name = "Credits:", Content = "Script made by Sporer66846\nUI Library made by Nebula Softworks\nVersion 3.0" })
DonateGroupbox:CreateButton({ Name = "Copy Bitcoin Wallet", Icon = NebulaIcons:GetIcon('bitcoin', 'Lucide'), Style = 1, Callback = function() setclipboard("bc1q54wdp3xrhmrpcqnlqf72rlmmjg7c83fj30n43u") end })
DonateGroupbox:CreateButton({ Name = "Copy Etherium Wallet", Icon = NebulaIcons:GetIcon('gpu', 'Lucide'), Style = 1, Callback = function() setclipboard("0x75BbcC2aaEdef8d5205c0B6DFCa85c20C9aE608A") end })
SocialsGroupbox:CreateButton({ Name = "Copy Discord Link", Icon = NebulaIcons:GetIcon('bot', 'Lucide'), Style = 1, Callback = function() setclipboard("https://discord.gg/CSzZPNwUWY") end })

-- Cached Friends System
local friendCache = {}
local function isPlayerFriend(targetPlayer)
    if friendCache[targetPlayer.UserId] ~= nil then return friendCache[targetPlayer.UserId] end
    friendCache[targetPlayer.UserId] = false
    task.spawn(function()
        local success, result = pcall(function() return Player:IsFriendsWith(targetPlayer.UserId) end)
        if success then friendCache[targetPlayer.UserId] = result end
    end)
    return friendCache[targetPlayer.UserId]
end

-- Helper Functions
local function IsVisible(part)
    if not Aimbot.VisibleCheck then return true end
    local char = Player.Character
    if not char then return false end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {char, part.Parent}
    local result = workspace:Raycast(camera.CFrame.Position, (part.Position - camera.CFrame.Position), params)
    return result == nil
end

local function GetPlayerColor(p)
    if Visuals.UseTeamColor and p.Team then return p.TeamColor.Color end
    local baseColor = Visuals.CurrentColor
    if Visuals.InverseFriends and isPlayerFriend(p) then
        local h, s, v = baseColor:ToHSV()
        return Color3.fromHSV((h + 0.5) % 1, s, v) 
    end
    return baseColor
end

-- Combat Functions
RunService.Heartbeat:Connect(function()
    if Combat.Triggerbot then
        local mouseLoc = UserInputService:GetMouseLocation()
        local ray = camera:ViewportPointToRay(mouseLoc.X, mouseLoc.Y)
        local result = workspace:Raycast(ray.Origin, ray.Direction * 1000)
        if result and result.Instance and result.Instance.Parent:FindFirstChild("Humanoid") then
            local hitPlayer = Players:GetPlayerFromCharacter(result.Instance.Parent)
            if hitPlayer and hitPlayer ~= Player then
                if Aimbot.TeamCheck and hitPlayer.Team == Player.Team then return end
                task.wait(Combat.TriggerDelay)
                mouse1click()
            end
        end
    end
end)

local LastCameraRotation = camera.CFrame
RunService.RenderStepped:Connect(function()
    if Combat.NoRecoil then
        if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then camera.CFrame = LastCameraRotation end
        LastCameraRotation = camera.CFrame
    else LastCameraRotation = camera.CFrame end
end)

local function UpdateVisualizer()
    if not Aimbot.Visualizer then return end
    local startPos = camera.CFrame.Position
    local startVel = camera.CFrame.LookVector * Aimbot.BulletSpeed
    local gravity = Vector3.new(0, -Aimbot.BulletDropAmount, 0)
    for i = 1, 20 do
        if not VisualizerLines[i] then VisualizerLines[i] = Drawing.new("Line"); VisualizerLines[i].Thickness = 1.5; VisualizerLines[i].Color = Color3.new(0, 1, 0) end
        local t1, t2 = (i - 1) * 0.1, i * 0.1
        local p1 = startPos + (startVel * t1) + (0.5 * gravity * t1^2)
        local p2 = startPos + (startVel * t2) + (0.5 * gravity * t2^2)
        local screenPos1, on1 = camera:WorldToViewportPoint(p1)
        local screenPos2, on2 = camera:WorldToViewportPoint(p2)
        if on1 and on2 then
            VisualizerLines[i].From = Vector2.new(screenPos1.X, screenPos1.Y)
            VisualizerLines[i].To = Vector2.new(screenPos2.X, screenPos2.Y)
            VisualizerLines[i].Visible = true
        else VisualizerLines[i].Visible = false end
    end
end

-- Main Loop
RunService.RenderStepped:Connect(function(dt)
    UpdateVisualizer()
    if Main.WalkSpeedEnabled and Player.Character and Player.Character:FindFirstChild("Humanoid") then Player.Character.Humanoid.WalkSpeed = Main.WalkSpeed end
    if Main.JumpPowerEnabled and Player.Character and Player.Character:FindFirstChild("Humanoid") then Player.Character.Humanoid.JumpPower = Main.JumpPower end

    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= Player then
            if not ESPDrawings[p] then ESPDrawings[p] = { Tracer = Drawing.new("Line"), NameText = Drawing.new("Text") } end
            local drawings = ESPDrawings[p]
            drawings.Tracer.Visible = false
            drawings.NameText.Visible = false

            if p.Character and p.Character:FindFirstChild("HumanoidRootPart") and p.Character:FindFirstChild("Humanoid") then
                if p.Character.Humanoid.Health > 0 then
                    local color = (Target == p) and Color3.new(1, 0, 0) or GetPlayerColor(p)
                    local highlight = espFolder:FindFirstChild(p.Name .. "_ESP")
                    if Visuals.ESP then
                        if not highlight then highlight = Instance.new("Highlight", espFolder); highlight.Name = p.Name .. "_ESP"; highlight.FillTransparency = 1; highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop end
                        highlight.Adornee = p.Character
                        highlight.OutlineColor = color
                    elseif highlight then highlight:Destroy() end

                    local screenPos, onScreen = camera:WorldToViewportPoint(p.Character.HumanoidRootPart.Position)
                    if onScreen then
                        if Visuals.Tracers then
                            drawings.Tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
                            drawings.Tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                            drawings.Tracer.Color = color
                            drawings.Tracer.Visible = true
                        end
                        if Visuals.ESP then
                            local head = p.Character:FindFirstChild("Head")
                            local namePos = head and camera:WorldToViewportPoint(head.Position + Vector3.new(0, 3, 0)) or screenPos
                            drawings.NameText.Text = isPlayerFriend(p) and "(Friend) " .. p.Name or p.Name
                            drawings.NameText.Position = Vector2.new(namePos.X, namePos.Y)
                            drawings.NameText.Color = color
                            drawings.NameText.Center = true
                            drawings.NameText.Outline = true
                            drawings.NameText.Visible = true
                        end
                    end
                end
            end
        end
    end
end)

-- Aimbot Logic (Restored Target Filtering)
local function GetAimbotTarget()
    local closest = nil
    local bestValue = math.huge
    local mouseLoc = UserInputService:GetMouseLocation()

    for _, p in pairs(Players:GetPlayers()) do
        if p ~= Player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and p.Character:FindFirstChild("Humanoid") then
            if p.Character.Humanoid.Health <= 0 then continue end
            if Aimbot.TeamCheck and p.Team == Player.Team then continue end

            local root = p.Character.HumanoidRootPart
            local targetPartName = Aimbot.TargetPart == "Legit" and "Head" or Aimbot.TargetPart
            local part = p.Character:FindFirstChild(targetPartName) or root

            local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
            local distToMouse = (Vector2.new(mouseLoc.X, mouseLoc.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
            local distToPlayer = (root.Position - (Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") and Player.Character.HumanoidRootPart.Position or Vector3.zero)).Magnitude

            if onScreen and distToMouse <= Aimbot.FOV and distToPlayer <= Aimbot.Range and IsVisible(part) then
                if Aimbot.Filtering == "ClosestToMouse" and distToMouse < bestValue then bestValue = distToMouse; closest = p
                elseif Aimbot.Filtering == "ClosestToPlayer" and distToPlayer < bestValue then bestValue = distToPlayer; closest = p
                elseif Aimbot.Filtering == "LowestHealth" and p.Character.Humanoid.Health < bestValue then bestValue = p.Character.Humanoid.Health; closest = p end
            end
        end
    end
    return closest
end

local function StartAimbot()
    if not Aimbot.Enabled then return end
    Target = GetAimbotTarget()
    if not Target then return end

    local switchInterval, lastSwitchTime, currentPart = 0.3, 0, nil
    
    AimbotConnection = RunService.RenderStepped:Connect(function(dt)
        if not Target or not Target.Character or Target.Character.Humanoid.Health <= 0 then StopAimbot() return end
        
        local root = Target.Character:FindFirstChild("HumanoidRootPart")
        local pos
        
        -- Legit Randomizer Logic Restored
        if Aimbot.TargetPart ~= "Legit" then
            local p = Target.Character:FindFirstChild(Aimbot.TargetPart)
            if not p then StopAimbot() return end
            pos = p.Position
        else
            if not currentPart or os.clock() - lastSwitchTime >= switchInterval then
                lastSwitchTime = os.clock()
                local parts = {Target.Character:FindFirstChild("Head"), Target.Character:FindFirstChild("UpperTorso") or Target.Character:FindFirstChild("Torso"), root}
                currentPart = parts[math.random(1, #parts)] or root
            end
            pos = currentPart.Position
        end
        
        if Aimbot.Prediction and root then
            local t = (pos - camera.CFrame.Position).Magnitude / Aimbot.BulletSpeed
            pos = pos + (root.Velocity * t)
            if Aimbot.BulletDrop then pos = pos + Vector3.new(0, 0.5 * Aimbot.BulletDropAmount * t^2, 0) end
        end
        
        local alpha = 1 - math.pow(1 - Aimbot.Smoothness, dt * 60)
        camera.CFrame = camera.CFrame:Lerp(CFrame.lookAt(camera.CFrame.Position, pos), math.clamp(alpha, 0, 1))
    end)
end

function StopAimbot()
    if AimbotConnection then AimbotConnection:Disconnect() AimbotConnection = nil end
    Target = nil
end

UserInputService.InputBegan:Connect(function(i, gp)
    if not gp and (i.UserInputType.Name == Aimbot.Keybind or i.KeyCode.Name == Aimbot.Keybind) then StartAimbot() end
end)
UserInputService.InputEnded:Connect(function(i)
    if i.UserInputType.Name == Aimbot.Keybind or i.KeyCode.Name == Aimbot.Keybind then StopAimbot() end
end)

Players.PlayerRemoving:Connect(function(p)
    if ESPDrawings[p] then ESPDrawings[p].Tracer:Remove(); ESPDrawings[p].NameText:Remove(); ESPDrawings[p] = nil end
end)

Starlight:LoadAutoloadConfig()
